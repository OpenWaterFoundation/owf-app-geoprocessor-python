# CommandListWidget - UI component to display list of commands with scrolling and status gutter
# ________________________________________________________________NoticeStart_
# GeoProcessor
# Copyright (C) 2017-2020 Open Water Foundation
# 
# GeoProcessor is free software:  you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     GeoProcessor is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with GeoProcessor.  If not, see <https://www.gnu.org/licenses/>.
# ________________________________________________________________NoticeEnd___

import functools
import logging
import math
from typing import Callable

from PyQt5 import QtCore, QtGui, QtWidgets
# Need the following for Qt.ControlModifier, etc.
from PyQt5.QtCore import Qt

from geoprocessor.core.CommandStatusType import CommandStatusType
from geoprocessor.commands.abstract.AbstractCommand import AbstractCommand
from geoprocessor.ui.core.GeoProcessorListModel import GeoProcessorListModel
from geoprocessor.ui.core.GeoProcessorListView import GeoProcessorListView
import geoprocessor.ui.util.qt_util as qt_util
import geoprocessor.util.app_util as app_util

# The following code is generated by QT Designer and returns a QString from UTF-8 string.
try:
    # _fromUtf8 = QtCore.QString.fromUtf8
    _fromUtf8 = lambda s: s
except AttributeError:
    def _fromUtf8(s: object):
        return s


class CommandListWidget(object):
    """
    This class is designed to be a modular component that can be placed in the overall GeoProcessor UI design.
    This class is not actually derived from QListWidget but may be in the future, in which case Qt integration will
    be more typical of a widget.  This is a complex component that manages the UI representation of the command list and
    left and right information/navigation components.

    The design of the components is as follows:

    GeoProcessor <- has a ----------- GeoProcessorUI
          ^         GeoProcessor             |
          |            'gp'                has a
          |                              CommandListWidget 'command_CommandListWidget'
          |                                  |
          |                                  V
          |                           CommandListWidget (this):  UI events result in calls to GeoProcessorListModel:
          |                                  |                    - load commands
          |                                  |                    - insert new commands
          |                                  |                    - remove commands
          |                                  |                    - edit commands
          |                                  |
          |                                  V
          |                                 has:     this.number_ListWidget  (str list on left side of commands,
          |                                  |                                coordinated with command_ListWidget)
          |                                  |       this.gutter_ListWidget  (str list on right side of commands,
          |                                  |                                coordinated with command_ListWidget)
          |                                  |       this.command_ListView   (GeoProcessorListView to display the
          |                                  |                                GeoProcessor.commands)
          |                                  |              |
          |                                  |             has a
          |                                  |          GeoProcessorListModel
          |                                  |              |
          |                                  V              V
          |------------ has a ------------ GeoProcessorListModel:  Data changes on GeoProcessorListModel
                     GeoProcessor            'gp_model'            propagate to CommandListWidget and its lists
                        'gp'                                       because of GeoProcessorListModel:
                                                                     add_model_listener, which results in calls to:
                                                                       ??
    """

    # noinspection PyPep8Naming
    def __init__(self, commands_GroupBox: QtWidgets.QGroupBox) -> None:
        """
        Initialize the CommandListWidget object with necessary global variables.

        Args:
            commands_GroupBox: The GroupBox being passed from GeoProcessorUI which will
                contain the command list widget that is built in this class.

        Returns:
            None
        """

        # Initialize the group box that will contain the command list widget
        self.commands_GroupBox = commands_GroupBox

        # Create empty object to hold the model listener
        self.command_model_listener = None

        # Create empty object to hold main ui listener
        self.command_main_ui_listener = None

        # An array to hold the list of commands coming from the geoprocessor
        # self.command_list: [AbstractCommand] = []

        # The list model to interface the processor to the QtListWidget
        self.gp_model: GeoProcessorListModel = None

        # Global ui elements...
        # Layout
        self.commands_GridLayout = None
        self.commands_HBoxLayout_Commands = None
        self.commands_HBoxLayout_Buttons = None

        # List widgets
        # self.command_ListWidget: QtWidgets.QListWidget or None = None
        # - use a view for commands since have the GeoProcessor that maintains the data as list of Command
        # - the view uses a GeoProcessorListModel 'gp_model', which has a reference to the GeoProcessor instance
        self.command_ListView: GeoProcessorListView or None = None
        # List of numbers on the left, aligned with command list
        # - UI actions are driven by this 'command_ListView' knowing about its events and listening to events
        #   independently generated in the 'gp_model'
        # - since a QListWidget, the data model list of strings to display
        self.number_ListWidget: QtWidgets.QListWidget or None = None
        # Gutter on the right, indicating color-coded issues
        # - UI actions are driven by this 'command_ListView' knowing about its events and listening to events
        #   independently generated in the 'gp_model'
        # - since a QListWidget, the data model list of strings to display
        self.gutter_ListWidget: QtWidgets.QListWidget or None = None

        # Buttons
        self.commands_RunAllCommands_PushButton: QtWidgets.QPushButton or None = None
        self.commands_RunSelectedCommands_PushButton: QtWidgets.QPushButton or None = None
        self.commands_ClearCommands_PushButton: QtWidgets.QPushButton or None = None

        # Keep track of errors and warnings in command list
        self.num_errors = 0
        self.num_warnings = 0

        # Keep track of block comments
        self.comment_block = False

        # Setup the user interface elements of the command list widget
        self.setup_ui()

    def __len__(self):
        """
        Returns:
            The size of the component, number of commands in the list model.
        """
        return len(self.gp_model)

    def add_model_listener(self, listener: GeoProcessorListModel) -> None:
        """
        Initialize the command list model listener.

        Args:
            listener: GeoProcessorListModel object that will listen for events from
                command list widget.

        Returns:
            Return if the listener is None.
        """
        if listener is None:
            return
        self.command_model_listener = listener

    # TODO smalers 2020-01-14 need to document interface methods
    def add_main_ui_listener(self, listener: Callable[..., None]) -> None:
        """
        Initialize the main ui listener.

        Args:
            listener: Model object that will listen for events from command list widget.
            It must have functions named:  ?

        Returns:
            None
        """
        if listener is None:
            return
        self.command_main_ui_listener = listener

    def command_list_deselect_all(self) -> None:
        """
        Deselect all commands in the command list.

        Returns:
            None
        """
        # There is no deselectAll() similar to selectAll().
        # Therefore, get the selected indices and deselect them.
        # Deselect all in the main commands
        self.command_ListView.clearSelection()
        # Also deselect all in the secondary lists
        self.number_ListWidget.clearSelection()
        self.gutter_ListWidget.clearSelection()
        # Update the UI state
        self.update_ui_status_commands()

    def command_list_select_all(self) -> None:
        """
        Select all commands in the command list.

        Returns:
            None
        """
        # Select all in the main commands
        self.command_ListView.selectAll()
        # Also select all in the secondary lists
        self.number_ListWidget.selectAll()
        self.gutter_ListWidget.selectAll()
        # Update the UI state
        self.update_ui_status_commands()

    @staticmethod
    def command_list_vertical_scroll(vs: QtWidgets.QScrollBar, value: int) -> None:
        """
        Connect the vertical scrolling with command list and numbered list.

        Args:
            vs: Vertical scroll bar to update.
            value: The value to set the vertical scroll bar to.

        Returns:
            None
        """
        vs.setValue(value)

    # TODO smalers 2020-01-18 does not seem to be called by anything
    def delete_numbered_list_item(self, index: int) -> None:
        """
        Delete the row in the numbered list and update the other numbers
        accordingly so they are still in order.

        Args:
            index: Index of numbered list item to be deleted.

        Returns:
            None
        """
        # Remove item at index
        self.number_ListWidget.takeItem(index)
        # Get the length of the numbered list
        count = self.number_ListWidget.count()

        # Update numbers past the deleted row
        for i in range(index, count):
            list_text = self.number_ListWidget.item(i).text()
            if list_text:
                num = int(self.number_ListWidget.item(i).text())
                num -= 1
                self.number_ListWidget.item(i).setText(str(num))

    def event_handler_commands_list_clicked(self, event: QtGui.QMouseEvent) -> None:
        """
        When clicking on a command list item also select the same
        row in the numbered list and gutter.

        Args:
            event: Release click event from numbered list, necessary as a parameter
                so that this function is recognized as a slot in response to a given signal
                or release click event.

        Returns:
            None
        """
        debug = True
        logger = None
        if debug:
            logger = logging.getLogger(__name__)

        # Detect whether shift or control key was pressed for mouse event
        control_pressed = False
        shift_pressed = False
        if event.modifiers() & Qt.ControlModifier:
            control_pressed = True
        if event.modifiers() & Qt.ShiftModifier:
            shift_pressed = True
        logger.info("Shift pressed=" + str(shift_pressed) + " control pressed=" + str(control_pressed))

        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        # TODO smalers 2020-01-19 evaluate not doing this if it results in flashing.
        # - instead, compare the selection status item by item below.
        # First clear previous selections from numbered list and gutter
        # - will be updated based on a review below
        self.number_ListWidget.clearSelection()
        self.gutter_ListWidget.clearSelection()

        # Update numbered list and gutter with selection to match the main list.
        # These are for widget...
        #   selected_q_indices = self.command_ListView.selectionModel().selectedIndexes()
        #   selected_indices = [item.row() for item in selected_q_indices]
        selected_indices = self.command_ListView.selectedIndexes()
        # if debug:
        #    logger.debug("number_ListWidget size=" + str(self.number_ListWidget.count()) +
        #                 " gutterListWidget size=" + str(self.gutter_ListWidget.count()))
        for index in selected_indices:
            # 'index' is a QModelIndex, so need to request the row
            row = index.row()
            if debug:
                logger.debug("Updating selection of secondary lists for row " + str(row))
            number_list_item = self.number_ListWidget.item(row)
            number_list_item.setSelected(True)
            gutter_list_item = self.number_ListWidget.item(row)
            gutter_list_item.setSelected(True)

        # Update the UI status
        self.update_ui_status_commands()

    def event_handler_commands_list_double_clicked(self, event: QtGui.QMouseEvent) -> None:
        """
        Handle a double click event on the command list.

        Args:
            event (QtGui.QMouseEvent):  Mouse event for the double-click.

        Returns:
            None
        """
        logger = logging.getLogger(__name__)
        # Let the main UI know
        row = self.command_ListView.indexAt(event.pos()).row();
        logger.info("Double click detected on command list row [" + str(row) + "]")
        self.command_main_ui_listener.ui_action_command_list_double_click(row)

    def event_handler_button_run_all_commands_clicked(self, event: QtCore.QEvent) -> None:
        """
        Notify GeoProcessorListModel that the run all commands button has been clicked.

        Args:
            event: Button clicked event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        self.notify_model_listener_main_ui_listener_run_all_commands_clicked()

    def event_handler_button_run_selected_commands_clicked(self, event: QtCore.QEvent) -> None:
        """
        Notify GeoProcessorListModel that the run selected commands button has been clicked.

        Args:
            event: Button clicked event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        selected_q_indices = self.command_ListView.selectedIndexes()
        selected_indices = [item.row() for item in selected_q_indices]
        self.notify_model_listener_main_ui_listener_run_selected_commands_clicked(selected_indices)

    def event_handler_button_clear_commands_clicked(self, event: QtCore.QEvent) -> None:
        """
        When clicking on the clear commands button clear all commands if none
        individually selected or only clear the selected commands.

        Args:
            event: Button clicked event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        selected_indices = self.command_ListView.selectedIndexes()
        if selected_indices:
            # Open a message box to confirm with the user that they want to delete all of the commands.
            response = qt_util.new_message_box(
                QtWidgets.QMessageBox.Question,
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                "Are you sure you want to delete selected " + str(len(selected_indices)) + " commands?",
                "Clear Commands")

            # If the user confirms that they want to delete the selected commands, delete the commands.
            # - Delete using objects so indices are not an issue
            if response == QtWidgets.QMessageBox.Yes:
                self.gp_model.clear_selected_commands(selected_indices)
        else:
            # Open a message box to confirm with the user that they want to delete all of the commands.
            response = qt_util.new_message_box(
                QtWidgets.QMessageBox.Question,
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                "Are you sure you want to delete ALL the commands?",
                "Clear Commands")

            # If the user confirms that they want to delete the selected commands, delete the commands.
            # - Delete using objects so indices are not an issue
            if response == QtWidgets.QMessageBox.Yes:
                self.gp_model.clear_all_commands()

        # TODO smalers 2020-01-19 need to do this via a listener
        # Check to see if command list modified. If so notify the main ui
        self.command_main_ui_listener.update_ui_main_window_title()

    # TODO smalers 2020-01-19 should not need this now
    def event_handler_decrease_indent_button_clicked(self) -> None:

        """
        Notify the GeoProcessorListModel that one of the increase indent buttons have been clicked.

        Returns:
            None
        """
        selected_indices = self.get_selected_indices()
        self.gp_model.decrease_indent_command_string(selected_indices)
        return
        selected_q_indices = self.command_ListView.selectedIndexes()
        selected_indices = [item.row() for item in selected_q_indices]
        self.notify_model_listener_decrease_indent_button_clicked(selected_indices)
        self.update_selected_commands(selected_indices)

        # Check to see if command list modified. If so notify the main ui
        self.command_main_ui_listener.update_ui_main_window_title()

    # TODO smalers 2020-01-19 should not need this now
    def event_handler_increase_indent_button_clicked(self) -> None:
        """
        Notify the GeoProcessorListModel that one of the increase indent buttons have been clicked.

        Returns:
            None
        """
        selected_indices = self.get_selected_indices()
        self.gp_model.indent_command_string(selected_indices)
        return
        selected_q_indices = self.command_ListView.selectedIndexes()
        selected_indices = [item.row() for item in selected_q_indices]
        self.notify_model_listener_increase_indent_button_clicked(selected_indices)
        # self.update_selected_commands(selected_indices)

        # Check to see if command list modified. If so notify the main ui
        self.command_main_ui_listener.update_ui_main_window_title()

    def event_handler_gutter_clicked(self, event: QtCore.QEvent) -> None:
        """
        When clicking on a gutter item also select the same
        row in the command list and the numbered list.

        Args:
            event: User click event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        index = self.gutter_ListWidget.currentRow()
        self.number_ListWidget.setCurrentRow(index)
        self.command_ListView.setCurrentRow(index)

    def event_handler_numbered_list_item_clicked(self, event: QtCore.QEvent) -> None:
        """
        When clicking on a numbered list item also select the same
        row in the command list and the gutter.

        Args:
            event: Release click event from numbered list, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        index = self.number_ListWidget.currentRow()
        model_index = self.gp_model.createIndex(index, -1)
        self.command_ListView.setCurrentIndex(model_index)
        self.gutter_ListWidget.setCurrentRow(index)

        selected_command = self.gp_model.gp.commands[index]
        command_status = selected_command.command_status
        run_status = command_status.run_status
        if run_status is CommandStatusType.WARNING or run_status is CommandStatusType.FAILURE:
            self.notify_main_ui_listener_numbered_list_clicked()

    def event_handler_numbered_list_item_hover(self, event: QtGui.QHoverEvent) -> None:
        """
        Notify main ui that the numbered list is being hovered over.

        Args:
            event: event from mouseEnter event

        Returns:
            None
        """
        self.notify_main_ui_listener_numbered_list_on_hover(event)

    def get_command_list_position(self) -> QtCore.QPoint:
        """
        Returns the position of the mouse to display the context menu.

        Returns: The current position of command list widget which is
        used in GeoProcessorUI to display the context menu on command list
        selection in the proper place
        """
        return self.command_ListView.mapToGlobal(QtCore.QPoint(0, 0))

    def get_selected_index(self) -> int or None:
        """
        Return the index of the current selected command list item.

        Returns:
            The index 0+ of the first current command that is selected, or None if nothing is selected.
        """
        selected_indices = self.command_ListView.selectedIndexes()
        if selected_indices is None or selected_indices == 0:
            return None
        else:
            return selected_indices[0].row()

    def get_selected_indices(self) -> [int]:
        """
        Return the selected indices from selected command list items.

        Returns:
            An array of integers representing the selected indices from command list.
            Sorted in ascending order
        """
        selected_indices = self.command_ListView.selectedIndexes()
        # Convert QModelIndex to simple int
        for i in range(len(selected_indices)):
            selected_indices[i] = selected_indices[i].row()
        # TODO smalers 2020-01-19 don't think the following is needed
        # selected_indices.sort()
        return selected_indices

    def group_box_resize(self, event: QtGui.QResizeEvent) -> None:
        """
        Update the size of the gutter to ensure that it doesn't scroll and that it
        appropriately displays a good overview of all issues.

        Args:
            event: Resize event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        # Get the current height of the gutter
        current_height = self.gutter_ListWidget.height()
        # Check the count of all commands
        # count = self.command_ListView.count()
        logger = logging.getLogger(__name__)
        command_count = 0
        if self.gp_model is None:
            command_count = 0
        elif self.gp_model.gp is None:
            command_count = 0
        elif self.gp_model.gp.commands is None:
            command_count = 0
        else:
            command_count = len(self.gp_model.gp.commands)
        count = command_count
        # Get the height of all items
        current_items_height = 16 * count
        # Make sure count is never 0, if so set to 1
        if count == 0:
            count = 1

        item_height = math.floor(current_height / count)
        # logger.info("Gutter size=" + str(self.gutter_ListWidget.count()))
        if current_items_height > current_height - 4:
            for i in range(0, command_count):
                item = self.gutter_ListWidget.item(i)
                item.setSizeHint(QtCore.QSize(-1, item_height))
        else:
            for i in range(0, command_count):
                item = self.gutter_ListWidget.item(i)
                item.setSizeHint(QtCore.QSize(-1, 16))

        # Update last item in list to always fill whole space, for better appearance
        # and to also ensure there is never any scrolling.
        # could be improved upon in the future
        # new gutter height
        need_to_set_gutter_height = False  # Don't think this is needed because other code sets
        if need_to_set_gutter_height:
            new_height = item_height * count
            if new_height > current_height - 4:
                # 4 offers as a buffer
                last_item_height = item_height + (current_height - new_height - 4)
                # update height of last item
                # TODO smalers added the following check, otherwise the app crashed
                # if self.gutter_ListWidget.item(count - 1) is not None:
                self.gutter_ListWidget.item(count - 1).setSizeHint(QtCore.QSize(-1, last_item_height))

    def gutter_error_at_row(self, index: int) -> None:
        """
        Set gutter row to red if there is a command line error on this row.

        Args:
            index: Index of row in gutter with error.

        Returns:
            None
        """
        item = self.gutter_ListWidget.item(index)
        item.setBackground(QtCore.Qt.red)

    def gutter_list_sync_with_commands(self) -> None:
        """
        Reset the gutter list to match the commands.
        This is typically called when a command file has been read from a file, new command file, etc.

        Returns:
            None
        """
        # Clear all the gutter list items
        self.gutter_ListWidget.clear()
        # Add numbered list items with line numbers
        num_commands = len(self.gp_model)
        for i in range(num_commands):
            # Add empty item to the gutter list
            item = QtWidgets.QListWidgetItem()
            # Get the row height hint from the command list
            command_list_row_height_hint = self.command_ListView.sizeHintForRow(i)
            # Set the size hint to the same as the main command list so that rows align
            item.setSizeHint(QtCore.QSize(-1, command_list_row_height_hint))
            self.gutter_ListWidget.addItem(item)

    def gutter_warning_at_row(self, index: int) -> None:
        """
        Set gutter row to yellow if there is a command line warning on this row.

        Args:
            index: Index of row in gutter with a warning.

        Returns:
            None
        """
        item = self.gutter_ListWidget.item(index)
        item.setBackground(QtCore.Qt.yellow)

    def list_model_clear_all_commands(self, gp_model: GeoProcessorListModel) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of clearing all commands.

        Returns:
            None.
        """
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def list_model_clear_selected_commands(self, gp_model: GeoProcessorListModel, selected_indices: [int]) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of clearing selected commands.

        Returns:
            None.
        """
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        if selected_indices is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def list_model_indent_change(self, gp_model: GeoProcessorListModel) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of changing command indent.

        Returns:
            None.
        """
        # logger = logging.getLogger(__name__)
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        # self.number_list_sync_with_commands()  # Should not change
        # self.gutter_list_sync_with_commands()  # Should not change
        # Update the UI status
        # Repaint the view
        # self.command_ListView.repaint()
        self.update_ui_status_commands()

    def list_model_insert_commands_at_index(self, gp_model: GeoProcessorListModel, insert_index: int) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of inserting commands.

        Returns:
            None.
        """
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        if insert_index is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def list_model_read_command_file(self, gp_model: GeoProcessorListModel, cmd_filepath: str) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of reading a command file.

        Args:
            gp_model:
                GeoProcessorListModel instance that generated the event.
            cmd_filepath:
                Path to command file that was read.
        Returns:
            None.
        """
        # Add the following to avoid IDE warnings
        if gp_model is None:
            pass
        if cmd_filepath is None:
            pass
        logger = logging.getLogger(__name__)
        logger.info("In CommandListWidget.list_model_read_command_file()")
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def notify_main_ui_listener_numbered_list_clicked(self) -> None:
        """
        Notify the main ui listener that the numbered list item has been clicked.

        Returns:
            None
        """
        self.command_main_ui_listener.show_command_status()

    def notify_main_ui_listener_numbered_list_on_hover(self, event: QtGui.QHoverEvent) -> None:
        """
        Notify the main ui listener that the numbered list item is being hovered over.

        Args:
            event: Hover event passed from numbered list mouseEnter event

        Returns:
            None
        """
        self.command_main_ui_listener.show_command_status_tooltip(event)

    def notify_main_ui_listener_right_click(self, q_pos: int) -> None:
        """
        Notify the main ui listener or a command line right click event.

        Args:
            q_pos: The position of the context menu

        Returns:
            None
        """
        self.command_main_ui_listener.ui_action_command_list_right_click(q_pos)

    def notify_model_listener_decrease_indent_button_clicked(self, selected_indices: [int]) -> None:
        """
        Notify the model listener that one of the decrease indent button has been clicked.

        Args:
            selected_indices: A list of integers representing the index of the
                commands to decrease the indent of.

        Returns:
            None
        """
        # TODO smalers 2020-01-19 should not need to do this now
        # self.command_model_listener.decrease_indent_command_string(selected_indices)

    def notify_model_listener_increase_indent_button_clicked(self, selected_indices: [int]) -> None:
        """
        Notify the model listener that one of the indent button has been clicked.

        Args:
            selected_indices: A list of integers representing the index of the
                commands to add indent to.

        Returns:
            None
        """
        # TODO smalers 2019-01-19 should not need to do this now
        # self.command_model_listener.indent_command_string(selected_indices)
        # self.gp_model.indent_command_string(selected_indices)

    def notify_model_listener_main_ui_listener_run_all_commands_clicked(self) -> None:
        """
        Notify the model listener that the run all commands button has been clicked.

        Returns:
            None
        """
        # self.command_model_listener.run_all_commands()
        self.gp_model.gp.run_commands()
        self.command_main_ui_listener.show_results()

    def notify_model_listener_main_ui_listener_run_selected_commands_clicked(self, selected_indices: [int]) -> None:
        """
        Notify the model listener that the geoprocessor.

        Args:
            selected_indices: A list of integers representing the index of the
                commands selected.

        Returns:
            None
        """
        # self.command_model_listener.run_selected_commands(selected_indices)
        self.gp_model.gp.run_selected_commands(selected_indices)
        self.command_main_ui_listener.show_results()

    def notify_main_ui_listener_refresh_results(self) -> None:
        """
        Notify the main ui that the results should be refreshed.

        Returns:
            None
        """
        self.command_main_ui_listener.show_results()

    def number_list_sync_with_commands(self) -> None:
        """
        Reset the number list to match the commands.
        This is typically called when a command file has been read from a file, new command file, etc.

        Returns:
            None
        """
        # Clear all the number list items
        self.number_ListWidget.clear()
        # Add number list items with line numbers
        num_commands = len(self.gp_model)
        for i in range(num_commands):
            # Get the row height hint from the command list
            command_list_row_height_hint = self.command_ListView.sizeHintForRow(i)
            # Add numbers to number list
            item = QtWidgets.QListWidgetItem()
            item.setText(str(i + 1))
            item.setTextAlignment(QtCore.Qt.AlignRight)
            # Set the size hint to the same as the main command list so that rows align
            item.setSizeHint(QtCore.QSize(-1, command_list_row_height_hint))
            ## item.mouseReleaseEvent = self.show_command_status_tooltip
            self.number_ListWidget.addItem(item)

        # Update the list width based on the number of commands and resulting maximum number
        self.update_numbered_list_width()

    def numbered_list_error_at_row(self, index: int) -> None:
        """
        Add the error icon to the numbered list row with an error.

        Args:
            index: Index of numbered list item where error occurred.

        Returns:
            None
        """
        # Get item from index
        item = self.number_ListWidget.item(index)
        # Get the error icon from path
        icon_path = app_util.get_property("ProgramResourcesPath").replace('\\', '/')
        icon_path = icon_path + "/images/error.gif"
        # Create icon
        error_icon = QtGui.QIcon(icon_path)
        # Add icon to QListWidgetItem
        item.setIcon(error_icon)

    def numbered_list_warning_at_row(self, index: int) -> None:
        """
        Add the warning icon to the numbered list row with an warning.

        Args:
            index: index of numbered list item where warning occurred.

        Returns:
            None
        """
        # Get item from index
        item = self.number_ListWidget.item(index)
        # Get the warning icon from path
        icon_path = app_util.get_property("ProgramResourcesPath").replace('\\', '/')
        icon_path = icon_path + "/images/warning.gif"
        # Create icon
        error_icon = QtGui.QIcon(icon_path)
        # Add icon to QListWidgetItem
        item.setIcon(error_icon)

    def numbered_list_unknown_at_row(self, index: int) -> None:
        """
        Add the unknown icon to the numbered list row with an unknown.

        Args:
            index: index of numbered list item where unkown occurred.

        Returns:
            QListWidgetItem
        """
        item = self.number_ListWidget.item(index)
        # Get the unknown icon from path
        icon_path = app_util.get_property("ProgramResourcesPath").replace('\\', '/')
        icon_path = icon_path + "/images/unknown.gif"
        # Create icon
        error_icon = QtGui.QIcon(icon_path)
        # Add icon to QListWidgetItem
        item.setIcon(error_icon)

    def x_set_command_list(self, command_list: [AbstractCommand]) -> None:
        """
        This method is no longer used.  Instead, use set_gp_model().

        Assign the command list to the passed in command list
        coming from geoprocessor in the GeoProcessorListModel.

        Args:
            command_list: Array of commands

        Returns: None
        """
        self.command_list = command_list

    def set_gp_model(self, gp_model: GeoProcessorListModel) -> None:
        """
        Set the GeoProcessorListModel for the widget, so that the widget can interact with the command list.

        Args:
            gp_model: GeoProcessorListModel that maintains the list of Command instances.

        Returns:
            None
        """
        logger = logging.getLogger(__name__)
        # Keep a local reference to the model for convenience
        self.gp_model = gp_model
        # Also set in the QListView, to be handled by Qt
        self.command_ListView.setModel(gp_model)
        logger.debug("Set model, has " + str(len(self.gp_model.gp.commands)) + " commands.")

        # The main command view will update automatically but need to update the gutter and numbered lists.
        # - do this by having this class listen for changes on the model, and make UI changes accordingly
        # self.update_command_list_widget()
        self.gp_model.add_model_listener(self)

    # TODO smalers 2020-01-14 is this called by anything?
    def setup_ui(self) -> None:
        """
        Setup all GUI elements of the CommandListWidget Area including the command list, the numbered
        list to the left of the commands and the gutter to the right of the commands.

        Returns:
            None
        """

        # Add event handler for QGroupBox resize event
        self.commands_GroupBox.resizeEvent = self.group_box_resize
        self.commands_GroupBox.setObjectName(_fromUtf8("commands_GroupBox"))
        self.commands_GroupBox.setTitle("Commands (0 commands, 0 selected, 0 with failures, 0 with warnings)")

        # Add basic QListWidget elements to design the command list
        self.setup_ui_command_list_widget_layout()
        self.setup_ui_command_list_widget_numbered_list()
        self.setup_ui_command_list_widget_command_list()
        # Connect scrolling between commands list and numbered list
        vs1 = self.command_ListView.verticalScrollBar()
        vs2 = self.number_ListWidget.verticalScrollBar()
        vs1.valueChanged.connect(functools.partial(self.command_list_vertical_scroll, vs2))
        vs2.valueChanged.connect(functools.partial(self.command_list_vertical_scroll, vs1))
        self.setup_ui_command_list_widget_gutter()

        # Buttons
        self.setup_ui_command_list_widget_button_run_selected_commands()
        self.setup_ui_command_list_widget_button_run_all_commands()
        # Spacer makes sure that buttons on left and right are correctly positioned
        spacer_item = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.commands_HBoxLayout_Buttons.addItem(spacer_item)
        self.setup_ui_command_list_widget_button_clear_commands()

    def setup_ui_command_list_widget_command_list(self) -> None:
        """
        Setup the command list for the command list widget.

        Returns:
            None
        """
        # Commands area list
        # self.command_ListView = QtWidgets.QListWidget(self.commands_GroupBox)
        # self.command_ListView = QtWidgets.QListView(self.commands_GroupBox)
        self.command_ListView = GeoProcessorListView(self.commands_GroupBox)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("MS Shell Dlg 2"))
        self.command_ListView.setFont(font)
        self.command_ListView.setAutoScroll(True)
        self.command_ListView.setDragDropOverwriteMode(False)
        self.command_ListView.setAlternatingRowColors(True)
        self.command_ListView.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.command_ListView.setProperty("isWrapping", False)
        self.command_ListView.setLayoutMode(QtWidgets.QListView.SinglePass)
        self.command_ListView.setWordWrap(False)
        self.command_ListView.setSelectionRectVisible(False)
        # Remap list events to event handling functions
        self.command_ListView.mouseReleaseEvent = self.event_handler_commands_list_clicked
        self.command_ListView.mouseDoubleClickEvent = self.event_handler_commands_list_double_clicked
        self.command_ListView.setObjectName(_fromUtf8("command_ListView"))
        self.command_ListView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.commands_HBoxLayout_Commands.addWidget(self.command_ListView)
        # Define listeners to handle events
        # Listen for a change in item selection within the command_ListView widget.
        # self.command_ListView.itemSelectionChanged.connect(self.update_ui_status_commands)
        doSelectionChanged = False
        if doSelectionChanged:
            selection_model = self.command_ListView.selectionModel()
            # Use the following because connect() is shown as unresolved reference in PyCharm
            # noinspection PyUnresolvedReferences
            #selection_model.selectionChanged.connect(self.update_ui_status_commands)
        else:
            # Do clicked event
            self.command_ListView.clicked.connect(self.update_ui_status_commands)
        # Other connections
        # Connect right-click of command_ListView widget item.
        self.command_ListView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.command_ListView.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        # Use the following because connect() is shown as unresolved reference in PyCharm
        # noinspection PyUnresolvedReferences
        self.command_ListView.customContextMenuRequested.connect(self.notify_main_ui_listener_right_click)

    def setup_ui_command_list_widget_gutter(self) -> None:
        """
        Setup the gutter to the right of the command list for command list widget.

        Returns:
            None
        """
        logger = logging.getLogger(__name__)
        logger.info("Initializing gutter")
        # Gutter
        self.gutter_ListWidget = QtWidgets.QListWidget(self.commands_GroupBox)
        self.gutter_ListWidget.setFixedWidth(21)
        self.gutter_ListWidget.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.gutter_ListWidget.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.gutter_ListWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.gutter_ListWidget.setObjectName('gutter')
        # Connect gutter click to custom gutter_clicked function
        self.gutter_ListWidget.mouseReleaseEvent = self.event_handler_gutter_clicked
        self.commands_HBoxLayout_Commands.addWidget(self.gutter_ListWidget)

    def setup_ui_command_list_widget_layout(self) -> None:
        """
        Setup the layout for the command list widget.

        Returns:
            None
        """
        # Add a grid layout to group box
        self.commands_GridLayout = QtWidgets.QGridLayout(self.commands_GroupBox)

        # Create a horizontal box layout for the numbered list, command list, and the gutter
        self.commands_HBoxLayout_Commands = QtWidgets.QHBoxLayout()
        self.commands_GridLayout.addLayout(self.commands_HBoxLayout_Commands, 0, 0)

        # Create a horizontal box layout for the buttons
        self.commands_HBoxLayout_Buttons = QtWidgets.QHBoxLayout()
        self.commands_GridLayout.addLayout(self.commands_HBoxLayout_Buttons, 1, 0)

        # Set spacing between the two horizontal layouts to none
        self.commands_HBoxLayout_Commands.setSpacing(0)

    def setup_ui_command_list_widget_numbered_list(self) -> None:
        """
        Setup the numbered list to left of command list.

        Returns:
            None
        """
        # Create a list next to command list that reflects command line numbers
        self.number_ListWidget = QtWidgets.QListWidget()
        self.number_ListWidget.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.number_ListWidget.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.number_ListWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.number_ListWidget.setFocusPolicy(QtCore.Qt.NoFocus)
        self.number_ListWidget.setMouseTracking(True)
        self.number_ListWidget.mouseReleaseEvent = self.event_handler_numbered_list_item_clicked
        self.number_ListWidget.mouseMoveEvent = self.event_handler_numbered_list_item_hover
        self.number_ListWidget.setObjectName("numbered_list")
        self.number_ListWidget.addItem('')
        self.commands_HBoxLayout_Commands.addWidget(self.number_ListWidget)
        self.update_numbered_list_width()

    def setup_ui_command_list_widget_button_run_selected_commands(self) -> None:
        """
        Setup the run selected commands button for the command list widget.

        Returns:
            None
        """
        # Commands area buttons under the list
        self.commands_RunSelectedCommands_PushButton = QtWidgets.QPushButton(self.commands_GroupBox)
        self.commands_RunSelectedCommands_PushButton.setEnabled(False)
        self.commands_RunSelectedCommands_PushButton.setDefault(False)
        self.commands_RunSelectedCommands_PushButton.setFlat(False)
        self.commands_RunSelectedCommands_PushButton.setObjectName(_fromUtf8("commands_RunSelectedCommands_PushButton"))
        self.commands_RunSelectedCommands_PushButton.setText("Run Selected Commands")
        self.commands_RunSelectedCommands_PushButton.setToolTip("Run selected commands from above to generate results.")
        self.commands_HBoxLayout_Buttons.addWidget(self.commands_RunSelectedCommands_PushButton)
        # Connect the Run Selected Commands button.
        self.commands_RunSelectedCommands_PushButton.clicked.connect(
            self.event_handler_button_run_selected_commands_clicked)

    def setup_ui_command_list_widget_button_run_all_commands(self) -> None:
        """
        Setup the run all commands button for the command list widget.

        Returns:
            None
        """
        self.commands_RunAllCommands_PushButton = QtWidgets.QPushButton(self.commands_GroupBox)
        self.commands_RunAllCommands_PushButton.setEnabled(False)
        self.commands_RunAllCommands_PushButton.setObjectName(_fromUtf8("commands_RunAllCommands_PushButton"))
        self.commands_RunAllCommands_PushButton.setText("Run All Commands")
        self.commands_RunAllCommands_PushButton.setToolTip("Run all commands from above to generate results.")
        self.commands_HBoxLayout_Buttons.addWidget(self.commands_RunAllCommands_PushButton)
        # Connect the Run All Commands button.
        self.commands_RunAllCommands_PushButton.clicked.connect(self.event_handler_button_run_all_commands_clicked)

    def setup_ui_command_list_widget_button_clear_commands(self) -> None:
        """
        Setup the clear commands button for the command list widget.

        Returns:
            None
        """
        self.commands_ClearCommands_PushButton = QtWidgets.QPushButton(self.commands_GroupBox)
        self.commands_ClearCommands_PushButton.setEnabled(False)
        self.commands_ClearCommands_PushButton.setObjectName(_fromUtf8("commands_ClearCommands_PushButton"))
        self.commands_ClearCommands_PushButton.setText("Clear Commands")
        self.commands_ClearCommands_PushButton.setToolTip(
            "Clear selected commands.  Clear all commands if none are selected.")
        self.commands_HBoxLayout_Buttons.addWidget(self.commands_ClearCommands_PushButton)
        # Connect the Clear Commands button.
        self.commands_ClearCommands_PushButton.clicked.connect(self.event_handler_button_clear_commands_clicked)

    def update_selected_commands(self, selected_indices: [int]) -> None:
        """
        Update which commands are selected. Selected commands get
        reset when refreshing UI content with commands in GeoProcessor but
        we want the selected items to stay selected unless the user de-selects
        them.

        Args:
            selected_indices: A list of integers representing the index of the
                selected items

        Returns:
            None
        """
        for i in range(0, len(selected_indices)):
            index = selected_indices[i]
            self.command_ListView.item(index).setSelected(True)
            self.number_ListWidget.item(index).setSelected(True)
            self.gutter_ListWidget.item(index).setSelected(True)

    def update_ui_status_commands(self) -> None:
        """
        Update the UI status for Commands area.
        Count the number of items (each item is a command string) in the Command_List widget.
        Update the total_commands class variable to the current number of command items in the Command_List widget.
        Update the selected_commands class variable to the current number of selected command items.
        Update the Command_List widget label to display the total and selected number of commands within the widget.

        Returns:
            None
        """
        # Count the number of items (each item is a command string) in the Command_List widget.
        total_commands = len(self.gp_model)

        # If there is at least one command in the Command_List widget, enable the "Run All Commands" button and the
        # "Clear Commands" button. If not, disable the "Run All Commands" button and the "Clear Commands" button.
        if total_commands > 0:
            self.commands_RunAllCommands_PushButton.setEnabled(True)
            self.commands_ClearCommands_PushButton.setEnabled(True)
        else:
            self.commands_RunAllCommands_PushButton.setEnabled(False)
            self.commands_ClearCommands_PushButton.setEnabled(False)

        # Count the number of selected items (each item is a command string) in the Command_List widget.
        selected_commands = len(self.command_ListView.selectedIndexes())

        # If there is at least one selected command in the Command_List widget, enable the "Run Selected Commands"
        # button. If not, disable the "Run Selected Commands" button.
        if selected_commands > 0:
            self.commands_RunSelectedCommands_PushButton.setEnabled(True)
        else:
            self.commands_RunSelectedCommands_PushButton.setEnabled(False)

        # Update the Command_List widget label to display the total and selected number of commands.
        self.commands_GroupBox.setTitle(
            "Commands ({} commands, {} selected, {} with failures, {} with warnings)".format(
                total_commands, selected_commands, self.num_errors, self.num_warnings))

    def x_update_command_list(self, command_string: str) -> None:
        """
        This method is no longer used.  Instead, add or remove commands in the model.

        Add data to the command list.

        Args:
            command_string: a command string to add to the command list

        Returns:
            None
        """
        # If inserting blank line
        if not command_string:
            item = QtWidgets.QListWidgetItem()
            item.setText("")
            qsize = QtCore.QSize()
            qsize.setHeight(16)
            qsize.setWidth(self.command_ListView.size().width())
            item.setSizeHint(qsize)
            self.command_ListView.addItem(item)
            return
        
        item = QtWidgets.QListWidgetItem()
        item.setText(command_string.rstrip())
        qsize = QtCore.QSize()
        qsize.setHeight(16)
        qsize.setWidth(self.command_ListView.size().width())
        item.setSizeHint(qsize)
        if command_string.strip() == "/*":
            self.comment_block = True
        # Check to see if comment block started or ended
        if command_string.strip()[0] == '#' or self.comment_block is True:
            item.setForeground(QtGui.QColor(68, 121, 206))
        self.command_ListView.addItem(item)

        if command_string.strip() == "*/":
            self.comment_block = False

    def update_command_list_widget(self) -> None:
        """
        This method is no longer used.  Instead, update data in the model.

        Update the command list widget from a command list that
        has already been initialized.

        Returns:
            None
        """
        # Start by clearing all data from the command list widget
        # self.command_ListView.clear()
        self.number_ListWidget.clear()
        self.gutter_ListWidget.clear()

        self.comment_block = False

        # Loop through command_list from geoprocessor and add data to command list widget
        for i, command in self.gp_model.gp.commands:
            command_string = command.command_string
            # self.update_command_list(command_string)
            self.update_numbered_list(i)
            self.update_gutter()

        self.number_ListWidget.addItem("")

    def update_numbered_list(self, index: int) -> None:
        """
        Add a new line to numbered list in accordance with command list
        given the index of the command list.

        Args:
            index: index of numbered list to add

        Returns:
            None
        """
        # Increment index to index starting at 1
        index += 1
        # Add numbers to numbered list
        item = QtWidgets.QListWidgetItem()
        item.setText(str(index))
        item.setTextAlignment(QtCore.Qt.AlignRight)
        item.setSizeHint(QtCore.QSize(-1, 16))
        ## item.mouseReleaseEvent = self.show_command_status_tooltip
        self.number_ListWidget.addItem(item)
        self.update_numbered_list_width()

    def update_numbered_list_width(self) -> None:
        """
        Update the width of the numbered list to allow elements to
        fit comfortably inside it.

        Returns:
            None
        """
        largest_int = self.number_ListWidget.count()
        myFont = QtGui.QFont()
        string = str(largest_int)
        fm = QtGui.QFontMetrics(myFont)
        maximum_int_width = fm.width(string)
        width = maximum_int_width + 38
        self.number_ListWidget.setFixedWidth(width)

    def update_ui_command_list_errors(self) -> None:
        """
        Once commands have been run. Loop through and check for any errors or warnings.

        Returns:
            None
        """
        # Start by clearing previous icons from numbered list and gutter
        for i in range(0, len(self.command_list)):
            numbered_list_item = self.number_ListWidget.item(i)
            numbered_list_item.setIcon(QtGui.QIcon())
            gutter_item = self.gutter_ListWidget.item(i)
            gutter_item.setBackground(QtCore.Qt.white)

        # Clear number of warnings and errors
        self.num_errors = 0
        self.num_warnings = 0

        # Now update the numbered list and gutter with current errors and warnings
        for i in range(0, len(self.command_list)):
            command_status = self.command_list[i].command_status.run_status
            if command_status is CommandStatusType.FAILURE:
                self.numbered_list_error_at_row(i)
                self.gutter_error_at_row(i)
                self.num_errors += 1
            elif command_status is CommandStatusType.WARNING:
                self.numbered_list_warning_at_row(i)
                self.gutter_warning_at_row(i)
                self.num_warnings += 1

    def update_gutter(self) -> None:
        """
        Add a new item to the gutter when a new command line has been added to the command list.

        Returns:
            None
        """
        # Add items to gutter
        item = QtWidgets.QListWidgetItem()
        item.setSizeHint(QtCore.QSize(-1, 16))
        self.gutter_ListWidget.addItem(item)
