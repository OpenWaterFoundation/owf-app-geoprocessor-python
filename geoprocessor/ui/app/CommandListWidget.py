# CommandListWidget - UI component to display list of commands with scrolling and status gutter
# ________________________________________________________________NoticeStart_
# GeoProcessor
# Copyright (C) 2017-2020 Open Water Foundation
# 
# GeoProcessor is free software:  you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     GeoProcessor is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with GeoProcessor.  If not, see <https://www.gnu.org/licenses/>.
# ________________________________________________________________NoticeEnd___

import functools
import logging
import math
from typing import Callable

from PyQt5 import QtCore, QtGui, QtWidgets
# Need the following for Qt.ControlModifier, etc.
from PyQt5.QtCore import Qt

from geoprocessor.commands.abstract.AbstractCommand import AbstractCommand
from geoprocessor.core.CommandPhaseType import CommandPhaseType
from geoprocessor.core.CommandStatusType import CommandStatusType

from geoprocessor.ui.app.GutterFrame import GutterFrame
from geoprocessor.ui.core.GeoProcessorListModel import GeoProcessorListModel
from geoprocessor.ui.core.GeoProcessorListView import GeoProcessorListView

import geoprocessor.ui.util.qt_util as qt_util
import geoprocessor.util.app_util as app_util

# The following code is generated by QT Designer and returns a QString from UTF-8 string.
try:
    # _fromUtf8 = QtCore.QString.fromUtf8
    _fromUtf8 = lambda s: s
except AttributeError:
    def _fromUtf8(s: object):
        return s


class CommandListWidget(object):
    """
    This class is designed to be a modular component that can be placed in the overall GeoProcessor UI design.
    This class is not actually derived from QListWidget but may be in the future, in which case Qt integration will
    be more typical of a widget.  This is a complex component that manages the UI representation of the command list and
    left and right information/navigation components.

    The design of the components is as follows:

    GeoProcessor <- has a ----------- GeoProcessorUI
          ^         GeoProcessor             |
          |            'gp'                has a
          |                              CommandListWidget 'command_CommandListWidget'
          |                                  |
          |                                  V
          |                           CommandListWidget (this):  UI events result in calls to GeoProcessorListModel:
          |                                  |                    - load commands
          |                                  |                    - insert new commands
          |                                  |                    - remove commands
          |                                  |                    - edit commands
          |                                  |
          |                                  V
          |                                 has:     this.number_ListWidget  (str list on left side of commands,
          |                                  |                                coordinated with command_ListWidget)
          |                                  |       this.gutter_ListWidget  (str list on right side of commands,
          |                                  |                                coordinated with command_ListWidget)
          |                                  |       this.command_ListView   (GeoProcessorListView to display the
          |                                  |                                GeoProcessor.commands)
          |                                  |              |
          |                                  |             has a
          |                                  |          GeoProcessorListModel
          |                                  |              |
          |                                  V              V
          |------------ has a ------------ GeoProcessorListModel:  Data changes on GeoProcessorListModel
                     GeoProcessor            'gp_model'            propagate to CommandListWidget and its lists
                        'gp'                                       because of GeoProcessorListModel:
                                                                     add_model_listener, which results in calls to:
                                                                       ??
    """

    # noinspection PyPep8Naming
    def __init__(self, commands_GroupBox: QtWidgets.QGroupBox) -> None:
        """
        Initialize the CommandListWidget object with necessary global variables.

        Args:
            commands_GroupBox: The GroupBox being passed from GeoProcessorUI which will
                contain the command list widget that is built in this class.

        Returns:
            None
        """

        # Initialize the group box that will contain the command list widget
        self.commands_GroupBox = commands_GroupBox

        # Create empty object to hold the model listener
        self.command_model_listener = None

        # Create empty object to hold main ui listener
        self.command_main_ui_listener = None

        # An array to hold the list of commands coming from the geoprocessor
        # self.command_list: [AbstractCommand] = []

        # The list model to interface the processor to the QtListWidget
        self.gp_model: GeoProcessorListModel = None

        # Global ui elements...
        # Layout
        self.commands_GridLayout = None
        self.commands_HBoxLayout_Commands = None
        self.commands_HBoxLayout_Buttons = None

        # List widgets
        # self.command_ListWidget: QtWidgets.QListWidget or None = None
        # - use a view for commands since have the GeoProcessor that maintains the data as list of Command
        # - the view uses a GeoProcessorListModel 'gp_model', which has a reference to the GeoProcessor instance
        self.command_ListView: GeoProcessorListView or None = None

        # List of numbers on the left, aligned with command list
        # - UI actions are driven by this 'command_ListView' knowing about its events and listening to events
        #   independently generated in the 'gp_model'
        # - since a QListWidget, the data model list of strings to display
        self.number_ListWidget: QtWidgets.QListWidget or None = None
        self.number_Frame: QtWidgets.QFrame or None = None
        self.number_VBoxLayout: QtWidgets.QVBoxLayout or None = None
        self.number_bottom_space_QFrame: QtWidgets.QFrame or None = None

        # Gutter on the right, indicating color-coded issues
        # - UI actions are driven by this 'command_ListView' knowing about its events and listening to events
        #   independently generated in the 'gp_model'
        # - since a QListWidget, the data model list of strings to display
        self.gutter_ListWidget: QtWidgets.QListWidget or None = None
        self.gutter_is_list: bool = False   # True to use list (old design) or False to use sime Frame area
        #self.gutter_Frame: QtWidgets.QFrame or None = None
        self.gutter_Frame: GutterFrame or None = None

        # Buttons
        self.commands_RunAllCommands_PushButton: QtWidgets.QPushButton or None = None
        self.commands_RunSelectedCommands_PushButton: QtWidgets.QPushButton or None = None
        self.commands_ClearCommands_PushButton: QtWidgets.QPushButton or None = None

        # Keep track of errors and warnings in command list
        self.num_errors = 0
        self.num_warnings = 0

        # Keep track of block comments
        self.comment_block = False

        # Setup the user interface elements of the command list widget
        self.setup_ui()

    def __len__(self):
        """
        Returns:
            The size of the component, number of commands in the list model.
        """
        return len(self.gp_model)

    def add_model_listener(self, listener: GeoProcessorListModel) -> None:
        """
        Initialize the command list model listener.

        Args:
            listener: GeoProcessorListModel object that will listen for events from
                command list widget.

        Returns:
            Return if the listener is None.
        """
        if listener is None:
            return
        self.command_model_listener = listener

    # TODO smalers 2020-01-14 need to document interface methods
    def add_main_ui_listener(self, listener: Callable[..., None]) -> None:
        """
        Initialize the main ui listener.

        Args:
            listener: Model object that will listen for events from command list widget.
            It must have functions named:  ?

        Returns:
            None
        """
        if listener is None:
            return
        self.command_main_ui_listener = listener

    def command_list_clear(self) -> None:
        """
        Clear the command list based on commands that are selected.

        Returns:
            None
        """

        selected_indices = self.command_ListView.selectedIndexes()
        if (selected_indices is not None) and (len(selected_indices) != 0) and \
                (len(selected_indices)) < len(self.gp_model):
            # Fewer than all commands are selected.
            # Open a message box to confirm with the user that they want to delete all of the commands.
            # - only do this if the selected commands are all the commands
            # - otherwise the dialog interrupts normal workflow
            do_confirm = False
            if do_confirm:
                response = qt_util.new_message_box(
                    QtWidgets.QMessageBox.Question,
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                    "Are you sure you want to delete selected " + str(len(selected_indices)) + " commands?",
                    "Clear Commands")
            else:
                # Always delete
                response = QtWidgets.QMessageBox.Yes

            # If the user confirms that they want to delete the selected commands, delete the commands.
            # - Delete using objects so indices are not an issue
            if response == QtWidgets.QMessageBox.Yes:
                self.gp_model.clear_selected_commands(selected_indices)
        elif (selected_indices is None) or (len(selected_indices) == 0) or \
                (len(selected_indices) == len(self.gp_model)):
            # Deleting all commands.
            # Open a message box to confirm with the user that they want to delete all of the commands.
            response = qt_util.new_message_box(
                QtWidgets.QMessageBox.Question,
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                "Are you sure you want to delete ALL the commands?",
                "Clear Commands")

            # If the user confirms that they want to delete the selected commands, delete the commands.
            # - Delete using objects so indices are not an issue
            if response == QtWidgets.QMessageBox.Yes:
                self.gp_model.clear_all_commands()

        # TODO smalers 2020-01-19 need to do this via a listener
        # Check to see if command list modified. If so notify the main UI.
        self.command_main_ui_listener.update_ui_main_window_title()

    def command_list_deselect_all(self) -> None:
        """
        Deselect all commands in the command list.

        Returns:
            None
        """
        # There is no deselectAll() similar to selectAll().
        # Therefore, get the selected indices and deselect them.
        # Deselect all in the main commands
        self.command_ListView.clearSelection()
        # Also deselect all in the secondary lists
        self.number_ListWidget.clearSelection()
        self.gutter_ListWidget.clearSelection()
        # Update the UI state
        self.update_ui_status_commands()

    def command_list_select_all(self) -> None:
        """
        Select all commands in the command list.

        Returns:
            None
        """
        # Select all in the main commands
        self.command_ListView.selectAll()
        # Also select all in the secondary lists
        self.number_ListWidget.selectAll()
        self.gutter_ListWidget.selectAll()
        # Update the UI state
        self.update_ui_status_commands()

    # TODO smalers 2020-03-12 Can't seem to get this to work for QListView
    def command_list_select_rows(self, rows: [int]) -> None:
        """
        Select commands in the command list given a list of indices.
        For now this does not work.

        Args:
            row ([int]): Array of rows (each 0+).

        Returns:
            None
        """
        for row in rows:
            # Select all in the main commands
            index = self.gp_model.createIndex(row,0)
            #self.command_ListView.select(index,QtWidgets.QAbstractItemView.SelectRow)
            # Is it possible to use the selection model to select?
            # See:  https://forum.qt.io/topic/57392/solved-how-to-click-the-first-row-in-qlistview-by-default/3
            # Can't find an example.
            # self.command_ListView.selectionModel.select(index,QItemSelectionModel.Select)
            # Also select all in the secondary lists
            # self.number_ListWidget.select(index)
            # self.gutter_ListWidget.select(index)

        # Update the UI state
        self.update_ui_status_commands()

    @staticmethod
    def command_list_vertical_scroll(vs: QtWidgets.QScrollBar, value: int) -> None:
        """
        Connect the vertical scrolling with command list and numbered list.

        Args:
            vs: Vertical scroll bar to update.
            value: The value to set the vertical scroll bar to.

        Returns:
            None
        """
        vs.setValue(value)

    # TODO smalers 2020-01-18 does not seem to be called by anything
    def delete_numbered_list_item(self, index: int) -> None:
        """
        Delete the row in the numbered list and update the other numbers
        accordingly so they are still in order.

        Args:
            index: Index of numbered list item to be deleted.

        Returns:
            None
        """
        # Remove item at index
        self.number_ListWidget.takeItem(index)
        # Get the length of the numbered list
        count = self.number_ListWidget.count()

        # Update numbers past the deleted row
        for i in range(index, count):
            list_text = self.number_ListWidget.item(i).text()
            if list_text:
                num = int(self.number_ListWidget.item(i).text())
                num -= 1
                self.number_ListWidget.item(i).setText(str(num))

    def event_handler_button_run_all_commands_clicked(self, event: QtCore.QEvent) -> None:
        """
        Notify GeoProcessorListModel that the run all commands button has been clicked.

        Args:
            event: Button clicked event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        self.notify_model_listener_main_ui_listener_run_all_commands_clicked()

    def event_handler_button_run_selected_commands_clicked(self, event: QtCore.QEvent) -> None:
        """
        Notify GeoProcessorListModel that the run selected commands button has been clicked.

        Args:
            event: Button clicked event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        selected_q_indices = self.command_ListView.selectedIndexes()
        selected_indices = [item.row() for item in selected_q_indices]
        self.notify_model_listener_main_ui_listener_run_selected_commands_clicked(selected_indices)

    def event_handler_button_clear_commands_clicked(self, event: QtCore.QEvent) -> None:
        """
        When clicking on the clear commands button clear all commands if none
        individually selected or only clear the selected commands.

        Args:
            event: Button clicked event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        # Call the method to do the work
        self.command_list_clear()

    def event_handler_command_list_clicked(self, event: QtGui.QMouseEvent) -> None:
        """
        When clicking on a command list item also select the same
        row in the numbered list and gutter.

        Args:
            event: Release click event from numbered list, necessary as a parameter
                so that this function is recognized as a slot in response to a given signal
                or release click event.

        Returns:
            None
        """
        debug = False
        logger = None
        if debug:
            logger = logging.getLogger(__name__)

        # Detect whether shift or control key was pressed for mouse event
        control_pressed = False
        shift_pressed = False
        if event.modifiers() & Qt.ControlModifier:
            control_pressed = True
        if event.modifiers() & Qt.ShiftModifier:
            shift_pressed = True
        if debug:
            logger.info("Shift pressed=" + str(shift_pressed) + " control pressed=" + str(control_pressed))

        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        # TODO smalers 2020-01-19 evaluate not doing this if it results in flashing.
        # - instead, compare the selection status item by item below.
        # First clear previous selections from numbered list and gutter
        # - will be updated based on a review below
        self.number_ListWidget.clearSelection()
        if self.gutter_is_list:
            self.gutter_ListWidget.clearSelection()
        else:
            # TODO smalers 2020-03-24 evaluate if need to do or will repaint do it
            pass

        # Update numbered list and gutter with selection to match the main list.
        # These are for widget...
        #   selected_q_indices = self.command_ListView.selectionModel().selectedIndexes()
        #   selected_indices = [item.row() for item in selected_q_indices]
        selected_indices = self.command_ListView.selectedIndexes()
        # if debug:
        #    logger.debug("number_ListWidget size=" + str(self.number_ListWidget.count()) +
        #                 " gutterListWidget size=" + str(self.gutter_ListWidget.count()))
        for index in selected_indices:
            # 'index' is a QModelIndex, so need to request the row
            row = index.row()
            if debug:
                logger.debug("Updating selection of secondary lists for row " + str(row))
            number_list_item = self.number_ListWidget.item(row)
            number_list_item.setSelected(True)
            gutter_list_item = self.number_ListWidget.item(row)
            gutter_list_item.setSelected(True)

        # Update the UI status
        self.update_ui_status_commands()

    def event_handler_command_list_double_clicked(self, event: QtGui.QMouseEvent) -> None:
        """
        Handle a double click event on the command list.

        Args:
            event (QtGui.QMouseEvent):  Mouse event for the double-click.

        Returns:
            None
        """
        logger = logging.getLogger(__name__)
        # Let the main UI know
        row = self.command_ListView.indexAt(event.pos()).row();
        logger.info("Double click detected on command list row [" + str(row) + "]")
        self.command_main_ui_listener.ui_action_command_list_double_click(row)

    # TODO smalers 2020-01-19 should not need this now - why?
    def event_handler_decrease_indent_button_clicked(self) -> None:

        """
        Notify the GeoProcessorListModel that one of the increase indent buttons have been clicked.

        Returns:
            None
        """
        selected_indices = self.get_selected_indices()
        self.gp_model.decrease_indent_command_string(selected_indices)
        return
        selected_q_indices = self.command_ListView.selectedIndexes()
        selected_indices = [item.row() for item in selected_q_indices]
        self.notify_model_listener_decrease_indent_button_clicked(selected_indices)
        self.update_selected_commands(selected_indices)

        # Check to see if command list modified. If so notify the main ui
        self.command_main_ui_listener.update_ui_main_window_title()

    # TODO smalers 2020-01-19 should not need this now - why?
    def event_handler_increase_indent_button_clicked(self) -> None:
        """
        Notify the GeoProcessorListModel that one of the increase indent buttons have been clicked.

        Returns:
            None
        """
        selected_indices = self.get_selected_indices()
        self.gp_model.indent_command_string(selected_indices)
        return
        selected_q_indices = self.command_ListView.selectedIndexes()
        selected_indices = [item.row() for item in selected_q_indices]
        self.notify_model_listener_increase_indent_button_clicked(selected_indices)
        self.update_selected_commands(selected_indices)

        # Check to see if command list modified. If so notify the main ui
        self.command_main_ui_listener.update_ui_main_window_title()

    def event_handler_gutter_clicked(self, event: QtGui.QMouseEvent) -> None:
        """
        Gutter was clicked.
        Select the corresponding (nearest) row in the command list and the numbered list.
        Because the gutter vertical dimension is

        Args:
            event: User click event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        debug = True
        if debug:
            logger = logging.getLogger(__name__)

        if debug:
            logger.debug("Clicked in gutter at position " + str(event.x()) + "," + str(event.y()))

        # Calculate the list row using simple math
        gutter_height = self.gutter_Frame.height()
        if gutter_height == 0:
            row = 0
        else:
            row = int(float(event.y())/float(gutter_height)*len(self.gp_model))
        if debug:
            logger.debug("Gutter click corresponds to command row " + str(row))
        # TODO smalers 2020-03-24 same issues as below setting the row

        # self.number_ListWidget.setCurrentRow(index)
        do_command_list = False
        if do_command_list:
            # TODO smalers 2020-03-23 the following does not work since not a widget - can't find an example
            # self.command_ListView.setCurrentRow(index)
            # model_index = self.gp_model.createIndex(index,-1)
            #self.gp_model.selectionModel().setCurrentIndex(model_index,QtCore.QItemSelectionModel.SelectCurrent)
            #self.command_ListView.selectionModel.setCurrentIndex(model_index,QtCore.QItemSelectionModel.SelectCurrent)
            pass

    def event_handler_gutter_list_clicked(self, event: QtCore.QEvent) -> None:
        """
        When clicking on a gutter item also select the same
        row in the command list and the numbered list.

        Args:
            event: User click event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        debug = True
        if debug:
            logger = logging.getLogger(__name__)
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        index = self.gutter_ListWidget.currentRow()
        if debug:
            logger.debug("Clicked in gutter in row " + str(index + 1))
        self.number_ListWidget.setCurrentRow(index)
        do_command_list = False
        if do_command_list:
            # TODO smalers 2020-03-23 the following does not work since not a widget - can't find an example
            # self.command_ListView.setCurrentRow(index)
            model_index = self.gp_model.createIndex(index,-1)
            #self.gp_model.selectionModel().setCurrentIndex(model_index,QtCore.QItemSelectionModel.SelectCurrent)
            #self.command_ListView.selectionModel.setCurrentIndex(model_index,QtCore.QItemSelectionModel.SelectCurrent)

    def event_handler_numbered_list_item_clicked(self, event: QtCore.QEvent) -> None:
        """
        When clicking on a numbered list item also select the same
        row in the command list and the gutter.

        Args:
            event: Release click event from numbered list, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        index = self.number_ListWidget.currentRow()
        model_index = self.gp_model.createIndex(index, -1)
        self.command_ListView.setCurrentIndex(model_index)
        self.gutter_ListWidget.setCurrentRow(index)

        selected_command = self.gp_model.gp.commands[index]
        command_status = selected_command.command_status
        run_status = command_status.run_status
        if run_status is CommandStatusType.WARNING or run_status is CommandStatusType.FAILURE:
            self.notify_main_ui_listener_numbered_list_clicked()

    def event_handler_numbered_list_item_hover(self, event: QtGui.QHoverEvent) -> None:
        """
        Notify main ui that the numbered list is being hovered over.

        Args:
            event: event from mouseEnter event

        Returns:
            None
        """
        self.notify_main_ui_listener_numbered_list_on_hover(event)

    def get_command_list_position(self) -> QtCore.QPoint:
        """
        Returns the position of the mouse to display the context menu.

        Returns: The current position of command list widget which is
        used in GeoProcessorUI to display the context menu on command list
        selection in the proper place
        """
        return self.command_ListView.mapToGlobal(QtCore.QPoint(0, 0))

    def get_selected_index(self) -> int or None:
        """
        Return the index of the current selected command list item.

        Returns:
            The index 0+ of the first current command that is selected, or None if nothing is selected.
        """
        selected_indices = self.command_ListView.selectedIndexes()
        if selected_indices is None or selected_indices == 0:
            return None
        else:
            return selected_indices[0].row()

    def get_selected_indices(self) -> [int]:
        """
        Return the selected indices from selected command list.

        Returns:
            An array of integers representing the selected indices from command list.
            Sorted in ascending order
        """
        selected_indices = self.command_ListView.selectedIndexes()
        # Convert QModelIndex to simple int
        for i in range(len(selected_indices)):
            selected_indices[i] = selected_indices[i].row()
        # TODO smalers 2020-01-19 don't think the following is needed
        # selected_indices.sort()
        return selected_indices

    def group_box_resize(self, event: QtGui.QResizeEvent) -> None:
        """
        Update the size of the gutter to ensure that it doesn't scroll and that it
        appropriately displays a good overview of all issues.

        Args:
            event: Resize event, necessary as a parameter so that this function
                is recognized as a slot in response to the button clicked signal from PyQt5.

        Returns:
            None
        """
        # Event is not actually used (list is examined)
        # - put in some code to use the event so PyCharm does not complain about not being used
        if event is None:
            pass

        if self.gutter_is_list:
            # Overly-complicated logic to deal with gutter size when it is a list
            # - TODO smalers 2020-03-23 remove this when Frame logic is tested out
            # Get the current height of the gutter
            current_height = self.gutter_ListWidget.height()
            # Check the count of all commands
            # count = self.command_ListView.count()
            logger = logging.getLogger(__name__)
            command_count = 0
            if self.gp_model is None:
                command_count = 0
            elif self.gp_model.gp is None:
                command_count = 0
            elif self.gp_model.gp.commands is None:
                command_count = 0
            else:
                command_count = len(self.gp_model.gp.commands)
            count = command_count
            # Get the height of all items
            current_items_height = 16 * count
            # Make sure count is never 0, if so set to 1
            if count == 0:
                count = 1

            item_height = math.floor(current_height / count)
            # logger.info("Gutter size=" + str(self.gutter_ListWidget.count()))
            if current_items_height > current_height - 4:
                for i in range(command_count):
                    item = self.gutter_ListWidget.item(i)
                    item.setSizeHint(QtCore.QSize(-1, item_height))
            else:
                for i in range(command_count):
                    item = self.gutter_ListWidget.item(i)
                    item.setSizeHint(QtCore.QSize(-1, 16))

            # Update last item in list to always fill whole space, for better appearance
            # and to also ensure there is never any scrolling.
            # could be improved upon in the future
            # new gutter height
            need_to_set_gutter_height = False  # Don't think this is needed because other code sets
            if need_to_set_gutter_height:
                new_height = item_height * count
                if new_height > current_height - 4:
                    # 4 offers as a buffer
                    last_item_height = item_height + (current_height - new_height - 4)
                    # update height of last item
                    # TODO smalers added the following check, otherwise the app crashed
                    # if self.gutter_ListWidget.item(count - 1) is not None:
                    self.gutter_ListWidget.item(count - 1).setSizeHint(QtCore.QSize(-1, last_item_height))

    def gutter_error_at_row(self, index: int) -> None:
        """
        Set gutter row to red if there is a command line error on this row.

        Args:
            index: Index of row in gutter with error.

        Returns:
            None
        """
        debug = True
        if debug:
            logger = logging.getLogger(__name__)
        if self.gutter_is_list:
            item = self.gutter_ListWidget.item(index)
            item.setBackground(QtCore.Qt.red)
            if debug:
                logger.debug("Set gutter error at index [" + str(index) + "]")
        else:
            # Nothing is needed here because gutter repaints itself
            pass

    def gutter_list_sync_with_commands(self) -> None:
        """
        Reset the gutter list to match the commands.
        This is typically called when a command file has been read from a file, new command file, etc.

        Returns:
            None
        """
        if self.gutter_is_list:
            # Clear all the gutter list items
            self.gutter_ListWidget.clear()
            # Add empty list item - background color is used but no other indicator
            num_commands = len(self.gp_model)
            for i in range(num_commands):
                # Add empty item to the gutter list
                item = QtWidgets.QListWidgetItem()
                # Row height SHOULD NOT align with main list because gutter is compressing all rows into the height
                # of the command list.
                # Row height should be gutter height divided by number of rows, but this won't work because integer
                # math will result in issues.
                # Get the row height hint from the command list
                # command_list_row_height_hint = self.command_ListView.sizeHintForRow(i)
                # Set the size hint to the same as the main command list so that rows align
                # item.setSizeHint(QtCore.QSize(-1, command_list_row_height_hint))
                self.gutter_ListWidget.addItem(item)
        else:
            # Repaint the frame in background color
            # - TODO smalers 2020-03-24 need to enable
            # self.gutter_Frame.setAutoFillBackground(True)
            # palette = self.gutter_Frame.palette()
            # palette.setColor(self.gutter_Frame.backgroundRole(), Qt.white)
            # self.gutter_Frame.setPalette(palette)
            pass

    def gutter_warning_at_row(self, index: int) -> None:
        """
        Set gutter row to yellow if there is a command line warning on this row.

        Args:
            index: Index of row in gutter with a warning.

        Returns:
            None
        """
        debug = True
        if debug:
            logger = logging.getLogger(__name__)
        if self.gutter_is_list:
            item = self.gutter_ListWidget.item(index)
            item.setBackground(QtCore.Qt.yellow)
            if debug:
                logger.debug("Set gutter warning at index [" + str(index) + "]")
        else:
            # Nothing is needed here because gutter repaints itself
            pass

    def list_model_clear_all_commands(self, gp_model: GeoProcessorListModel) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of clearing all commands.

        Returns:
            None.
        """
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def list_model_clear_selected_commands(self, gp_model: GeoProcessorListModel, selected_indices: [int]) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of clearing selected commands.

        Returns:
            None.
        """
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        if selected_indices is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def list_model_indent_change(self, gp_model: GeoProcessorListModel) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of changing command indent.

        Returns:
            None.
        """
        # logger = logging.getLogger(__name__)
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        # self.number_list_sync_with_commands()  # Should not change
        # self.gutter_list_sync_with_commands()  # Should not change
        # Update the UI status
        # Repaint the view
        # self.command_ListView.repaint()
        self.update_ui_status_commands()

    def list_model_insert_commands_at_index(self, gp_model: GeoProcessorListModel, insert_index: int) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of inserting commands.

        Returns:
            None.
        """
        # Put in the following to avoid warnings about not being used
        if gp_model is None:
            pass
        if insert_index is None:
            pass
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def list_model_read_command_file(self, gp_model: GeoProcessorListModel, cmd_filepath: str) -> None:
        """
        Required when GeoProcessorListModel.add_model_listener() has been called.
        Handle event of reading a command file.

        Args:
            gp_model:
                GeoProcessorListModel instance that generated the event.
            cmd_filepath:
                Path to command file that was read.

        Returns:
            None.
        """
        # Add the following to avoid IDE warnings
        if gp_model is None:
            pass
        if cmd_filepath is None:
            pass
        logger = logging.getLogger(__name__)
        logger.info("In CommandListWidget.list_model_read_command_file()")
        # The following is needed to make sure commands that were read result in updated error count
        # self.update_ui_command_list_errors()
        # The command view will already have been updated because it tracks the data model.
        # Also need to synchronize the number and gutter lists.
        self.number_list_sync_with_commands()
        self.gutter_list_sync_with_commands()
        # Update the UI status
        self.update_ui_status_commands()

    def notify_main_ui_listener_numbered_list_clicked(self) -> None:
        """
        Notify the main ui listener that the numbered list item has been clicked.

        Returns:
            None
        """
        self.command_main_ui_listener.show_command_status()

    def notify_main_ui_listener_numbered_list_on_hover(self, event: QtGui.QHoverEvent) -> None:
        """
        Notify the main ui listener that the numbered list item is being hovered over.

        Args:
            event: Hover event passed from numbered list mouseEnter event

        Returns:
            None
        """
        self.command_main_ui_listener.show_command_status_tooltip(event)

    def notify_main_ui_listener_right_click(self, q_pos: int) -> None:
        """
        Notify the main ui listener or a command line right click event.

        Args:
            q_pos: The position of the context menu

        Returns:
            None
        """
        self.command_main_ui_listener.ui_action_command_list_right_click(q_pos)

    def notify_model_listener_decrease_indent_button_clicked(self, selected_indices: [int]) -> None:
        """
        Notify the model listener that one of the decrease indent button has been clicked.

        Args:
            selected_indices: A list of integers representing the index of the
                commands to decrease the indent of.

        Returns:
            None
        """
        # TODO smalers 2020-01-19 should not need to do this now
        # self.command_model_listener.decrease_indent_command_string(selected_indices)

    def notify_model_listener_increase_indent_button_clicked(self, selected_indices: [int]) -> None:
        """
        Notify the model listener that one of the indent button has been clicked.

        Args:
            selected_indices: A list of integers representing the index of the
                commands to add indent to.

        Returns:
            None
        """
        # TODO smalers 2019-01-19 should not need to do this now
        # self.command_model_listener.indent_command_string(selected_indices)
        # self.gp_model.indent_command_string(selected_indices)

    def notify_model_listener_main_ui_listener_run_all_commands_clicked(self) -> None:
        """
        Notify the model listener that the run all commands button has been clicked.

        Returns:
            None
        """
        # self.command_model_listener.run_all_commands()
        self.gp_model.gp.run_commands()
        self.command_main_ui_listener.show_results()

    def notify_model_listener_main_ui_listener_run_selected_commands_clicked(self, selected_indices: [int]) -> None:
        """
        Notify the model listener that the geoprocessor.

        Args:
            selected_indices: A list of integers representing the index of the
                commands selected.

        Returns:
            None
        """
        # self.command_model_listener.run_selected_commands(selected_indices)
        self.gp_model.gp.run_selected_commands(selected_indices)
        self.command_main_ui_listener.show_results()

    def notify_main_ui_listener_refresh_results(self) -> None:
        """
        Notify the main ui that the results should be refreshed.

        Returns:
            None
        """
        self.command_main_ui_listener.show_results()

    def number_list_sync_with_commands(self) -> None:
        """
        Reset the number list to match the commands.
        This is typically called when a command file has been read from a file, new command file, etc.

        Returns:
            None
        """
        # Clear all the number list items
        self.number_ListWidget.clear()
        # Add number list items with line numbers
        num_commands = len(self.gp_model)
        for i in range(num_commands):
            # Get the row height hint from the command list
            command_list_row_height_hint = self.command_ListView.sizeHintForRow(i)
            # Add numbers to number list
            item = QtWidgets.QListWidgetItem()
            item.setText(str(i + 1))
            item.setTextAlignment(QtCore.Qt.AlignRight)
            # Set the size hint to the same as the main command list so that rows align
            item.setSizeHint(QtCore.QSize(-1, command_list_row_height_hint))
            ## item.mouseReleaseEvent = self.show_command_status_tooltip
            self.number_ListWidget.addItem(item)

        # Update the list width based on the number of commands and resulting maximum number
        self.update_numbered_list_width()

    def numbered_list_error_at_row(self, index: int) -> None:
        """
        Add the error icon to the numbered list row with an error.

        Args:
            index: Index of numbered list item where error occurred.

        Returns:
            None
        """
        debug = False
        if debug:
            logger = logging.getLogger(__name__)
        # Get item from index
        item = self.number_ListWidget.item(index)
        # Get the error icon from path
        icon_path = app_util.get_property("ProgramResourcesPath").replace('\\', '/')
        icon_path = icon_path + "/images/error.gif"
        # Create icon
        error_icon = QtGui.QIcon(icon_path)
        # Add icon to QListWidgetItem
        item.setIcon(error_icon)
        if debug:
            logger.debug("Set error icon at index [" + str(index) + "]")

    def numbered_list_warning_at_row(self, index: int) -> None:
        """
        Add the warning icon to the numbered list row with an warning.

        Args:
            index: index of numbered list item where warning occurred.

        Returns:
            None
        """
        debug = False
        if debug:
            logger = logging.getLogger(__name__)
        # Get item from index
        item = self.number_ListWidget.item(index)
        # Get the warning icon from path
        icon_path = app_util.get_property("ProgramResourcesPath").replace('\\', '/')
        icon_path = icon_path + "/images/warning.gif"
        # Create icon
        warning_icon = QtGui.QIcon(icon_path)
        # Add icon to QListWidgetItem
        item.setIcon(warning_icon)
        if debug:
            logger.debug("Set error icon at index [" + str(index) + "]")

    def numbered_list_unknown_at_row(self, index: int) -> None:
        """
        Add the unknown icon to the numbered list row with an unknown.

        Args:
            index: index of numbered list item where unkown occurred.

        Returns:
            QListWidgetItem
        """
        item = self.number_ListWidget.item(index)
        # Get the unknown icon from path
        icon_path = app_util.get_property("ProgramResourcesPath").replace('\\', '/')
        icon_path = icon_path + "/images/unknown.gif"
        # Create icon
        error_icon = QtGui.QIcon(icon_path)
        # Add icon to QListWidgetItem
        item.setIcon(error_icon)

    def set_gp_model(self, gp_model: GeoProcessorListModel) -> None:
        """
        Set the GeoProcessorListModel for the widget, so that the widget can interact with the command list.

        Args:
            gp_model: GeoProcessorListModel that maintains the list of Command instances.

        Returns:
            None
        """
        logger = logging.getLogger(__name__)
        # Keep a local reference to the model for convenience
        self.gp_model = gp_model
        self.gutter_Frame.gp_model = gp_model  # Needed to refresh the gutter
        # Also set in the QListView, to be handled by Qt
        self.command_ListView.setModel(gp_model)
        logger.debug("Set model, has " + str(len(self.gp_model.gp.commands)) + " commands.")

        # The main command view will update automatically but need to update the gutter and numbered lists.
        # - do this by having this class listen for changes on the model, and make UI changes accordingly
        # self.update_command_list_widget()
        self.gp_model.add_model_listener(self)

    def setup_ui(self) -> None:
        """
        Setup all GUI elements of the CommandListWidget Area including the command list, the numbered
        list to the left of the commands and the gutter to the right of the commands.
        This is called by GeoProcessorUI.setup_ui_commands() function.

        Returns:
            None
        """

        # Add event handler for QGroupBox resize event
        self.commands_GroupBox.resizeEvent = self.group_box_resize
        self.commands_GroupBox.setObjectName(_fromUtf8("commands_GroupBox"))
        # Initial status
        # - will be updated in update_ui_status_commands()
        self.commands_GroupBox.setTitle("Commands (0 commands, 0 selected, 0 with failures, 0 with warnings)")

        # Add basic QListWidget elements to design the command list
        # - add from left to right
        self.setup_ui_command_list_widget_layout()   # First set up layout
        self.setup_ui_command_list_widget_numbered_list()   # Numbered list on left
        self.setup_ui_command_list_widget_command_list()   # Command list in middle
        # Connect scrolling between commands list and numbered list
        vs1 = self.command_ListView.verticalScrollBar()
        vs2 = self.number_ListWidget.verticalScrollBar()
        # TODO smalers 2020-03-23 there is no scroll bar on the numbered list so ony connect one direction.
        # - scrolling the command QListView cases the numbered list QListWidget to scroll
        vs1.valueChanged.connect(functools.partial(self.command_list_vertical_scroll, vs2))
        # vs2.valueChanged.connect(functools.partial(self.command_list_vertical_scroll, vs1))
        self.setup_ui_command_list_widget_gutter()   # Gutter list on the right

        # Buttons
        self.setup_ui_command_list_widget_button_run_selected_commands()
        self.setup_ui_command_list_widget_button_run_all_commands()
        # Spacer makes sure that buttons on left and right are correctly positioned
        spacer_item = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.commands_HBoxLayout_Buttons.addItem(spacer_item)
        self.setup_ui_command_list_widget_button_clear_commands()

    def setup_ui_command_list_widget_command_list(self) -> None:
        """
        Setup the command list for the command list widget.

        Returns:
            None
        """
        debug = True
        if debug:
            logger = logging.getLogger(__name__)
        # Commands area list
        # self.command_ListView = QtWidgets.QListWidget(self.commands_GroupBox)
        # self.command_ListView = QtWidgets.QListView(self.commands_GroupBox)
        self.command_ListView = GeoProcessorListView(self.commands_GroupBox)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("MS Shell Dlg 2"))
        self.command_ListView.setFont(font)
        self.command_ListView.setAutoScroll(True)
        self.command_ListView.setDragDropOverwriteMode(False)
        self.command_ListView.setAlternatingRowColors(True)
        self.command_ListView.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.command_ListView.setProperty("isWrapping", False)
        self.command_ListView.setLayoutMode(QtWidgets.QListView.SinglePass)
        self.command_ListView.setWordWrap(False)
        self.command_ListView.setSelectionRectVisible(False)

        # Remap list events to event handling functions
        self.command_ListView.mouseReleaseEvent = self.event_handler_command_list_clicked
        self.command_ListView.mouseDoubleClickEvent = self.event_handler_command_list_double_clicked
        self.command_ListView.setObjectName(_fromUtf8("command_ListView"))
        self.command_ListView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.commands_HBoxLayout_Commands.addWidget(self.command_ListView)
        # Define listeners to handle events
        # Listen for a change in item selection within the command_ListView widget.
        # self.command_ListView.itemSelectionChanged.connect(self.update_ui_status_commands)
        doSelectionChanged = False
        if doSelectionChanged:
            selection_model = self.command_ListView.selectionModel()
            # Use the following because connect() is shown as unresolved reference in PyCharm
            # noinspection PyUnresolvedReferences
            #selection_model.selectionChanged.connect(self.update_ui_status_commands)
        else:
            # Do clicked event
            self.command_ListView.clicked.connect(self.update_ui_status_commands)
        # Handle key event on list for delete key and Enter for edit
        # - TODO smalers 2020-03-17 need to figure out how to handle Enter=edit and Delete=delete keys.
        # Other connections
        # Connect right-click of command_ListView widget item.
        self.command_ListView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.command_ListView.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        # Use the following because connect() is shown as unresolved reference in PyCharm
        # noinspection PyUnresolvedReferences
        self.command_ListView.customContextMenuRequested.connect(self.notify_main_ui_listener_right_click)

        # Set the height of the numbered list lower-left spacer to be the same as the main list scrollbar
        horizontal_scroll_height = self.command_ListView.horizontalScrollBar().height()
        if debug:
            logger.debug("Command list horizontal scrollbar height is " + str(horizontal_scroll_height))
        if self.number_bottom_space_QFrame is not None:
            self.number_bottom_space_QFrame.setFixedHeight(horizontal_scroll_height)

    def setup_ui_command_list_widget_gutter(self) -> None:
        """
        Setup the gutter to the right of the command list for command list widget.
        This is only initial setup.  The data for the list will be refreshed when commands are in the main area.

        Returns:
            None
        """
        debug = True
        if debug:
            logger = logging.getLogger(__name__)
            logger.info("Initializing gutter")
        if self.gutter_is_list:
            # Gutter is a list - original design
            self.gutter_ListWidget = QtWidgets.QListWidget(self.commands_GroupBox)
            self.gutter_ListWidget.setFixedWidth(21)
            self.gutter_ListWidget.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            self.gutter_ListWidget.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            self.gutter_ListWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
            self.gutter_ListWidget.setObjectName('gutter')
            # Connect gutter click to custom gutter_clicked function
            self.gutter_ListWidget.mouseReleaseEvent = self.event_handler_gutter_list_clicked
            self.commands_HBoxLayout_Commands.addWidget(self.gutter_ListWidget)
        else:
            # Gutter is a Frame that is drawn into - current design
            # self.gutter_Frame = QtWidgets.QFrame()
            self.gutter_Frame = GutterFrame(self.gp_model)
            # TODO smalers 2020-03-24 20 seems too wide
            # self.gutter_Frame.setFixedWidth(20)
            self.gutter_Frame.setFixedWidth(10)
            self.gutter_Frame.setObjectName('gutter')
            # Start set background of frame...
            # - TODO smalers 2020-03-24 need to enable handling painting
            # - just draw on background color, similar to TSTool
            # self.gutter_Frame.setAutoFillBackground(True)
            # palette = self.gutter_Frame.palette()
            # palette.setColor(self.gutter_Frame.backgroundRole(), Qt.white)
            # self.gutter_Frame.setPalette(palette)
            # Add an event handler for mouse click
            #self.command_ListView.mouseReleaseEvent = self.event_handler_gutter_clicked
            self.gutter_Frame.mousePressEvent = self.event_handler_gutter_clicked
            # Add the gutter to the layout of the CommandListWidget
            self.commands_HBoxLayout_Commands.addWidget(self.gutter_Frame)

    def setup_ui_command_list_widget_layout(self) -> None:
        """
        Setup the layout for the command list widget, which is the overall component.

        Returns:
            None
        """
        # Add a grid layout to group box
        self.commands_GridLayout = QtWidgets.QGridLayout(self.commands_GroupBox)

        # Create a horizontal box layout for the numbered list, command list, and the gutter
        self.commands_HBoxLayout_Commands = QtWidgets.QHBoxLayout()
        self.commands_GridLayout.addLayout(self.commands_HBoxLayout_Commands, 0, 0)

        # Create a horizontal box layout for the buttons
        self.commands_HBoxLayout_Buttons = QtWidgets.QHBoxLayout()
        self.commands_GridLayout.addLayout(self.commands_HBoxLayout_Buttons, 1, 0)

        # Set spacing between the two horizontal layouts to none
        self.commands_HBoxLayout_Commands.setSpacing(0)

    def setup_ui_command_list_widget_numbered_list(self) -> None:
        """
        Setup the numbered list to left of command list.

        Returns:
            None
        """
        debug = True
        debug_components = False
        if debug:
            logger = logging.getLogger(__name__)

        # Whether extra space should be added at bottom to align with active command list
        do_extra_space = True

        if do_extra_space:
            # Add extra space in the lower left.
            # Need to put the 'number_ListWidget' in another panel.
            self.number_Frame = QtWidgets.QFrame()
            if debug_components:
                # Start set background of frame...
                self.number_Frame.setAutoFillBackground(True)
                palette1 = self.number_Frame.palette()
                palette1.setColor(self.number_Frame.backgroundRole(), Qt.green)
                self.number_Frame.setPalette(palette1)
            # ...end set background of frame so can understand layout.
            self.number_VBoxLayout = QtWidgets.QVBoxLayout(self.number_Frame)
            self.number_VBoxLayout.setObjectName("number_VBoxLayout")
            # Don't want any additional buffer around components
            self.number_VBoxLayout.setSpacing(0)
            self.number_VBoxLayout.setMargin(0)
            self.number_VBoxLayout.setContentsMargins(0, 0, 0, 0)
            # Start code that is the same as below...
            self.number_ListWidget = QtWidgets.QListWidget()
            self.number_ListWidget.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            self.number_ListWidget.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            self.number_ListWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
            self.number_ListWidget.setFocusPolicy(QtCore.Qt.NoFocus)
            self.number_ListWidget.setMouseTracking(True)
            self.number_ListWidget.mouseReleaseEvent = self.event_handler_numbered_list_item_clicked
            self.number_ListWidget.mouseMoveEvent = self.event_handler_numbered_list_item_hover
            self.number_ListWidget.setObjectName("numbered_list")
            self.number_ListWidget.addItem('')
            # ... end of the code that is the same as below
            # Add the numbered list to the vertical layout
            self.number_VBoxLayout.addWidget(self.number_ListWidget)
            # Add a frame to take up space in the lower left
            self.number_bottom_space_QFrame = QtWidgets.QFrame()
            if debug_components:
                # Start set background of filler frame...
                self.number_bottom_space_QFrame.setAutoFillBackground(True)
                palette2 = self.number_bottom_space_QFrame.palette()
                palette2.setColor(self.number_bottom_space_QFrame.backgroundRole(), Qt.red)
                self.number_bottom_space_QFrame.setPalette(palette2)
                # ...end set background of filler frame so can understand layout.
            # Set the initial fixed height
            # - this is reset to the actual command list scroll bar height in setup_ui_command_list_widget_commmand_list
            horizontal_scroll_height = 30
            self.number_bottom_space_QFrame.setFixedHeight(horizontal_scroll_height)
            self.number_VBoxLayout.addWidget(self.number_bottom_space_QFrame)
            # Add the vertical layout to the horizontal layout
            self.commands_HBoxLayout_Commands.addWidget(self.number_Frame)
            self.update_numbered_list_width()
        else:
            # Create a list next to command list that reflects command line numbers
            # - keep this code as an example if if not called
            # - this generally works but has the following problem:
            #
            #  |   |                                                   |
            #  |   |               command list                        |
            #  |   |___________________________________________________|
            #  |XXX|<------------- command list scrollbar -----------> |
            #
            #  XXX is part of the numbered list whereas it should be dead space with same height as command
            # list scrollbar.  This leads to the numbered list not scrolling in sync with command list, even though
            # the row height is the same.
            #
            # Start code that is the same as above...
            self.number_ListWidget = QtWidgets.QListWidget()
            self.number_ListWidget.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            self.number_ListWidget.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
            self.number_ListWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
            self.number_ListWidget.setFocusPolicy(QtCore.Qt.NoFocus)
            self.number_ListWidget.setMouseTracking(True)
            self.number_ListWidget.mouseReleaseEvent = self.event_handler_numbered_list_item_clicked
            self.number_ListWidget.mouseMoveEvent = self.event_handler_numbered_list_item_hover
            self.number_ListWidget.setObjectName("numbered_list")
            self.number_ListWidget.addItem('')
            # ... end of the code that is the same as above
            self.commands_HBoxLayout_Commands.addWidget(self.number_ListWidget)
            self.update_numbered_list_width()

    def setup_ui_command_list_widget_button_run_selected_commands(self) -> None:
        """
        Setup the run selected commands button for the command list widget.

        Returns:
            None
        """
        # Commands area buttons under the list
        self.commands_RunSelectedCommands_PushButton = QtWidgets.QPushButton(self.commands_GroupBox)
        self.commands_RunSelectedCommands_PushButton.setEnabled(False)
        self.commands_RunSelectedCommands_PushButton.setDefault(False)
        self.commands_RunSelectedCommands_PushButton.setFlat(False)
        self.commands_RunSelectedCommands_PushButton.setObjectName(_fromUtf8("commands_RunSelectedCommands_PushButton"))
        self.commands_RunSelectedCommands_PushButton.setText("Run Selected Commands")
        self.commands_RunSelectedCommands_PushButton.setToolTip("Run selected commands from above to generate results.")
        self.commands_HBoxLayout_Buttons.addWidget(self.commands_RunSelectedCommands_PushButton)
        # Connect the Run Selected Commands button.
        self.commands_RunSelectedCommands_PushButton.clicked.connect(
            self.event_handler_button_run_selected_commands_clicked)

    def setup_ui_command_list_widget_button_run_all_commands(self) -> None:
        """
        Setup the run all commands button for the command list widget.

        Returns:
            None
        """
        self.commands_RunAllCommands_PushButton = QtWidgets.QPushButton(self.commands_GroupBox)
        self.commands_RunAllCommands_PushButton.setEnabled(False)
        self.commands_RunAllCommands_PushButton.setObjectName(_fromUtf8("commands_RunAllCommands_PushButton"))
        self.commands_RunAllCommands_PushButton.setText("Run All Commands")
        self.commands_RunAllCommands_PushButton.setToolTip("Run all commands from above to generate results.")
        self.commands_HBoxLayout_Buttons.addWidget(self.commands_RunAllCommands_PushButton)
        # Connect the Run All Commands button.
        self.commands_RunAllCommands_PushButton.clicked.connect(self.event_handler_button_run_all_commands_clicked)

    def setup_ui_command_list_widget_button_clear_commands(self) -> None:
        """
        Setup the clear commands button for the command list widget.

        Returns:
            None
        """
        self.commands_ClearCommands_PushButton = QtWidgets.QPushButton(self.commands_GroupBox)
        self.commands_ClearCommands_PushButton.setEnabled(False)
        self.commands_ClearCommands_PushButton.setObjectName(_fromUtf8("commands_ClearCommands_PushButton"))
        self.commands_ClearCommands_PushButton.setText("Clear Commands")
        self.commands_ClearCommands_PushButton.setToolTip(
            "Clear selected commands.  Clear all commands if none are selected.")
        self.commands_HBoxLayout_Buttons.addWidget(self.commands_ClearCommands_PushButton)
        # Connect the Clear Commands button.
        self.commands_ClearCommands_PushButton.clicked.connect(self.event_handler_button_clear_commands_clicked)

    def update_selected_commands(self, selected_indices: [int]) -> None:
        """
        Update which commands are selected.
        Selected commands get reset when refreshing UI content with commands in GeoProcessor but want the selected
        items to stay selected unless the user de-selects them.

        Args:
            selected_indices: A list of command list indices for the selected items.

        Returns:
            None
        """
        for i in range(len(selected_indices)):
            index = selected_indices[i]
            self.command_ListView.item(index).setSelected(True)
            self.number_ListWidget.item(index).setSelected(True)
            self.gutter_ListWidget.item(index).setSelected(True)

    def update_ui_status_commands(self) -> None:
        """
        Update the UI status for Commands area.
        Count the number of items (each item is a command string) in the Command_List widget.
        Update the total_commands class variable to the current number of command items in the Command_List widget.
        Update the selected_commands class variable to the current number of selected command items.
        Update the Command_List widget label to display the total and selected number of commands within the widget.

        Returns:
            None
        """
        # Count the number of items (each item is a command string) in the Command_List widget.
        total_commands = len(self.gp_model)

        # If there is at least one command in the Command_List widget, enable the "Run All Commands" button and the
        # "Clear Commands" button. If not, disable the "Run All Commands" button and the "Clear Commands" button.
        if total_commands > 0:
            self.commands_RunAllCommands_PushButton.setEnabled(True)
            self.commands_ClearCommands_PushButton.setEnabled(True)
        else:
            self.commands_RunAllCommands_PushButton.setEnabled(False)
            self.commands_ClearCommands_PushButton.setEnabled(False)

        # Count the number of selected items (each item is a command string) in the Command_List widget.
        selected_commands = len(self.command_ListView.selectedIndexes())

        # If there is at least one selected command in the Command_List widget, enable the "Run Selected Commands"
        # button. If not, disable the "Run Selected Commands" button.
        if selected_commands > 0:
            self.commands_RunSelectedCommands_PushButton.setEnabled(True)
        else:
            self.commands_RunSelectedCommands_PushButton.setEnabled(False)

        # Call code to count the errors
        # - TODO smalers 2020-03-22 this is called elsewhere
        # self.update_ui_command_list_errors()

        # Update the Command_List widget label to display the total and selected number of commands.
        self.commands_GroupBox.setTitle(
            "Commands ({} commands, {} selected, {} with failures, {} with warnings)".format(
                total_commands, selected_commands, self.num_errors, self.num_warnings))

        # Update the UI via listener so it can update the indent button state
        # - TODO smalers 2020-03-13 the listener is the main UI
        self.command_main_ui_listener.update_ui_status()

    def x_update_numbered_list(self, index: int) -> None:
        """
        Add a new line to numbered list in accordance with command list
        given the index of the command list.

        Args:
            index: index of numbered list to add

        Returns:
            None
        """
        # Increment index to index starting at 1
        index += 1
        # Add numbers to numbered list
        item = QtWidgets.QListWidgetItem()
        item.setText(str(index))
        item.setTextAlignment(QtCore.Qt.AlignRight)
        item.setSizeHint(QtCore.QSize(-1, 16))
        ## item.mouseReleaseEvent = self.show_command_status_tooltip
        self.number_ListWidget.addItem(item)
        self.update_numbered_list_width()

    def update_numbered_list_width(self) -> None:
        """
        Update the width of the numbered list to allow elements to
        fit comfortably inside it.

        Returns:
            None
        """
        largest_int = self.number_ListWidget.count()
        myFont = QtGui.QFont()
        string = str(largest_int)
        fm = QtGui.QFontMetrics(myFont)
        maximum_int_width = fm.width(string)
        width = maximum_int_width + 38
        self.number_ListWidget.setFixedWidth(width)
        # Also set the width on the container frame
        if self.number_bottom_space_QFrame is not None:
            self.number_bottom_space_QFrame.setFixedWidth(width)
        # Also set the width on the container frame
        # - TODO smalers 2020-03-23 this causes things to misbehave
        self.number_Frame.setFixedWidth(self.number_ListWidget.width())

    def update_ui_command_list_errors(self, command_phase_type=CommandPhaseType.RUN) -> None:
        """
        Once commands have been run. Loop through and check for any errors or warnings.
        This is called from:  GeoProcessorUI.command_completed().

        Returns:
            None
        """
        debug = False
        if debug:
            logger = logging.getLogger(__name__)
        # Start by clearing previous icons from numbered list and gutter
        blank_icon = QtGui.QIcon()
        for i in range(len(self.gp_model)):
            numbered_list_item = self.number_ListWidget.item(i)
            numbered_list_item.setIcon(blank_icon)
            if self.gutter_is_list:
                gutter_item = self.gutter_ListWidget.item(i)
                gutter_item.setBackground(QtCore.Qt.white)

        if not self.gutter_is_list:
            # Clear by redrawing in background color
            # - TODO smalers 2020-03-24 need to enable
            # self.gutter_Frame.setAutoFillBackground(True)
            # palette = self.gutter_Frame.palette()
            # palette.setColor(self.gutter_Frame.backgroundRole(), Qt.white)
            # self.gutter_Frame.setPalette(palette)
            pass

        # Clear number of warnings and errors
        self.num_errors = 0
        self.num_warnings = 0

        # Now update the numbered list and gutter with current errors and warnings
        for i in range(len(self.gp_model)):
            if command_phase_type is CommandPhaseType.INITIALIZATION:
                # Will be used after loading a command file, but have not run yet
                command_status = self.gp_model.gp.commands[i].command_status.initialization_status
                if debug:
                    logger.debug("Command [" + str(i) + "] initialization status = " + str(command_status))
            elif command_phase_type is CommandPhaseType.DISCOVERY:
                command_status = self.gp_model.gp.commands[i].command_status.discovery_status
            elif command_phase_type is CommandPhaseType.RUN:
                # Will be used by default, after running commands
                command_status = self.gp_model.gp.commands[i].command_status.run_status
                if debug:
                    logger.debug("Command [" + str(i) + "] run status = " + str(command_status))

            if command_status is CommandStatusType.FAILURE:
                self.numbered_list_error_at_row(i)
                self.gutter_error_at_row(i)
                self.num_errors += 1
            elif command_status is CommandStatusType.WARNING:
                self.numbered_list_warning_at_row(i)
                self.gutter_warning_at_row(i)
                self.num_warnings += 1

    def update_gutter(self) -> None:
        """
        Add a new item to the gutter when a new command line has been added to the command list.

        Returns:
            None
        """
        # Add items to gutter
        item = QtWidgets.QListWidgetItem()
        item.setSizeHint(QtCore.QSize(-1, 16))
        self.gutter_ListWidget.addItem(item)

    def x_set_command_list(self, command_list: [AbstractCommand]) -> None:
        """
        This method is no longer used.  Instead, use set_gp_model().

        Assign the command list to the passed in command list
        coming from geoprocessor in the GeoProcessorListModel.

        Args:
            command_list: Array of commands

        Returns: None
        """
        self.command_list = command_list

    def x_update_command_list(self, command_string: str) -> None:
        """
        This method is no longer used.  Instead, add or remove commands in the model.

        Add data to the command list.

        Args:
            command_string: a command string to add to the command list

        Returns:
            None
        """
        # If inserting blank line
        if not command_string:
            item = QtWidgets.QListWidgetItem()
            item.setText("")
            qsize = QtCore.QSize()
            qsize.setHeight(16)
            qsize.setWidth(self.command_ListView.size().width())
            item.setSizeHint(qsize)
            self.command_ListView.addItem(item)
            return

        item = QtWidgets.QListWidgetItem()
        item.setText(command_string.rstrip())
        qsize = QtCore.QSize()
        qsize.setHeight(16)
        qsize.setWidth(self.command_ListView.size().width())
        item.setSizeHint(qsize)
        if command_string.strip() == "/*":
            self.comment_block = True
        # Check to see if comment block started or ended
        if command_string.strip()[0] == '#' or self.comment_block is True:
            item.setForeground(QtGui.QColor(68, 121, 206))
        self.command_ListView.addItem(item)

        if command_string.strip() == "*/":
            self.comment_block = False

    def x_update_command_list_widget(self) -> None:
        """
        This method is no longer used.  Instead, update data in the model.

        Update the command list widget from a command list that
        has already been initialized.

        Returns:
            None
        """
        # Start by clearing all data from the command list widget
        # self.command_ListView.clear()
        self.number_ListWidget.clear()
        self.gutter_ListWidget.clear()

        self.comment_block = False

        # Loop through command_list from geoprocessor and add data to command list widget
        for i, command in self.gp_model.gp.commands:
            command_string = command.command_string
            # self.update_command_list(command_string)
            self.update_numbered_list(i)
            self.update_gutter()

        self.number_ListWidget.addItem("")

