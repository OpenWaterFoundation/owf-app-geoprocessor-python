import pytest
import geoprocessor.util.io_util as io_util
# importing app_util for testing the test_format_standard_header() function
# TODO @jurentie 02/27/2019 - Not sure if this is good testing practice?
import geoprocessor.util.app_util as app_util
import datetime
import getpass
import os
import platform
import sys

# Create a temporary text file for testing tarred and zipped files
@pytest.fixture
def text_file(tmpdir):
    file = tmpdir.join("test_file.txt")
    file.write("Hello World!")
    return str(file)


# Tests for expand_formatter()
def test_expand_formatter_filename_with_extension(text_file):
    """ Test function using the parameter '%F'. Should return the filename with the extension. """
    assert io_util.expand_formatter(text_file, '%F') == "test_file.txt"

def test_expand_formatter_filename_without_the_extension(text_file):
    """ Test function using the parameter '%f'. Should return the filename without extension. """
    assert io_util.expand_formatter(text_file, '%f') == "test_file"

def test_expand_formatter_full_path(text_file, tmpdir):
    """ Test function using the parameter '%P'. Should return the full path with filename and extension. """
    assert io_util.expand_formatter(text_file, '%P') == tmpdir.join("test_file.txt")

def test_expand_formatter_leading_path_without_filename_or_extension(text_file, tmpdir):
    """ Test function using parameter '%p'. Should return the full path without the filename """
    assert io_util.expand_formatter(text_file, '%p') == tmpdir

def test_expand_formatter_extension(text_file):
    """ Test function using parameter '%E'. Should return just the filename extension with '.'."""
    assert io_util.expand_formatter(text_file, '%E') == '.txt'

def test_expand_formatter_invalid_formatter(text_file):
    """ Test to see how function is handled with invalid parameter, should return None"""
    assert io_util.expand_formatter(text_file, '$h') == None

# Tests for format_standard_file_header()
def test_format_standard_file_header():
    """ Test the basic functionality of this function. Not passing any parameters. """
    # Hard coded the expected list output, but had to do so using variables and app_util to
    # get the values correct
    expected = []
    progname = os.path.basename(sys.argv[0])
    try:
        progver = app_util.program_properties['ProgramVersion']
    except KeyError as e:
        progver = "unknown"
    user = getpass.getuser()
    now = datetime.datetime.now().isoformat()
    host = platform.node()
    working_dir = ""
    args = sys.argv
    expected.append("File generated by...")
    expected.append("program:      " + progname + " " + progver)
    expected.append("user:         " + user)
    expected.append("date:         " + now)
    expected.append("host:         " + host)
    expected.append("directory:    " + working_dir)
    expected.append("command line: " + progname)
    column0 = len(progname) + 13
    column = column0  # Column position, starting at 1
    b = ""
    if args is not None:
        for arg in args:
            arg_len = len(arg)
            # Need 1 to account for blank between arguments...
            if (column + 1 + arg_len) > 120:
                # Put the argument on a new line...
                expected.append(b)
                b = ""
                b += arg
                column = column0 + arg_len
            else:
                # Put the argument on the same line...
                b += " " + arg
                column += (arg_len + 1)

    # Output the commands, with preference given to in-memory list of commands rather than command file
    expected.append(b)
    expected.append("-----------------------------------------------------------------------")
    assert pytest.approx(io_util.format_standard_file_header() == expected)


def test_format_standard_file_header_with_comment_line_prefix():
    """ Test this function passing in a comment line prefix. """
    # Hard coded the expected list output, but had to do so using variables and app_util to
    # get the values correct

    # Comment Line Prefix
    comment_line_prefix = "TEST PREFIX:"

    expected = []
    progname = os.path.basename(sys.argv[0])
    try:
        progver = app_util.program_properties['ProgramVersion']
    except KeyError as e:
        progver = "unknown"
    user = getpass.getuser()
    now = datetime.datetime.now().isoformat()
    host = platform.node()
    working_dir = ""
    args = sys.argv
    expected.append(comment_line_prefix + "File generated by...")
    expected.append(comment_line_prefix + "program:      " + progname + " " + progver)
    expected.append(comment_line_prefix + "user:         " + user)
    expected.append(comment_line_prefix + "date:         " + now)
    expected.append(comment_line_prefix + "host:         " + host)
    expected.append(comment_line_prefix + "directory:    " + working_dir)
    expected.append(comment_line_prefix + "command line: " + progname)
    column0 = len(progname) + 13
    column = column0  # Column position, starting at 1
    b = comment_line_prefix
    if args is not None:
        for arg in args:
            arg_len = len(arg)
            # Need 1 to account for blank between arguments...
            if (column + 1 + arg_len) > 120:
                # Put the argument on a new line...
                expected.append(b)
                b = ""
                b += comment_line_prefix
                column = column0 + arg_len
            else:
                # Put the argument on the same line...
                b += " " + arg
                column += (arg_len + 1)

    # Output the commands, with preference given to in-memory list of commands rather than command file
    expected.append(b)
    expected.append(comment_line_prefix + "-----------------------------------------------------------------------")
    assert pytest.approx(io_util.format_standard_file_header(comment_line_prefix) == expected)


def test_format_standard_file_header_max_width_80():
    """ Test this function with a specified max width of 80 """
    # Hard coded the expected list output, but had to do so using variables and app_util to
    # get the values correct
    expected = []
    progname = os.path.basename(sys.argv[0])
    try:
        progver = app_util.program_properties['ProgramVersion']
    except KeyError as e:
        progver = "unknown"
    user = getpass.getuser()
    now = datetime.datetime.now().isoformat()
    host = platform.node()
    working_dir = ""
    args = sys.argv
    expected.append("File generated by...")
    expected.append("program:      " + progname + " " + progver)
    expected.append("user:         " + user)
    expected.append("date:         " + now)
    expected.append("host:         " + host)
    expected.append("directory:    " + working_dir)
    expected.append("command line: " + progname)
    column0 = len(progname) + 13
    column = column0  # Column position, starting at 1
    b = ""
    if args is not None:
        for arg in args:
            arg_len = len(arg)
            # Need 1 to account for blank between arguments...
            if (column + 1 + arg_len) > 80:
                # Put the argument on a new line...
                expected.append(b)
                b = ""
                column = column0 + arg_len
            else:
                # Put the argument on the same line...
                b += " " + arg
                column += (arg_len + 1)

    # Output the commands, with preference given to in-memory list of commands rather than command file
    expected.append(b)
    expected.append("-----------------------------------------------------------------------")
    assert pytest.approx(io_util.format_standard_file_header("", 80) == expected)


def test_format_standard_file_header_is_xml():
    """ Test this function passing xml = True """
    # Hard coded the expected list output, but had to do so using variables and app_util to
    # get the values correct
    expected = []
    progname = os.path.basename(sys.argv[0])
    try:
        progver = app_util.program_properties['ProgramVersion']
    except KeyError as e:
        progver = "unknown"
    user = getpass.getuser()
    now = datetime.datetime.now().isoformat()
    host = platform.node()
    working_dir = ""
    args = sys.argv
    expected.append("File generated by...")
    expected.append("program:      " + progname + " " + progver)
    expected.append("user:         " + user)
    expected.append("date:         " + now)
    expected.append("host:         " + host)
    expected.append("directory:    " + working_dir)
    expected.append("command line: " + progname)
    column0 = len(progname) + 13
    column = column0  # Column position, starting at 1
    b = ""
    if args is not None:
        for arg in args:
            arg_len = len(arg)
            # Need 1 to account for blank between arguments...
            if (column + 1 + arg_len) > 120:
                # Put the argument on a new line...
                expected.append(b)
                b = ""
                column = column0 + arg_len
            else:
                # Put the argument on the same line...
                b += " " + arg
                column += (arg_len + 1)

    # Output the commands, with preference given to in-memory list of commands rather than command file
    expected.append(b)
    assert pytest.approx(io_util.format_standard_file_header("", 120, True) == expected)

def test_get_col_names_from_delimited_file():
    pass